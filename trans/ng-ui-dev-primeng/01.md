<header>

# 开始使用 Angular 和 Priming

</header>

这本书预先假定了打字稿和角点 2 的一些基本知识。无论如何，我们想给读者一个最重要的字体和角度的关键概念在这本书中使用的概述。我们将总结打字稿和角度特征，并以易懂、简单但解释深刻的部分介绍它们。在撰写本书时，当前的打字脚本和 Angular 版本分别为 2.3.x 和 4.2.x。读者还将第一次见到 PrimeNG UI 库，并通过三种不同的方式获得项目设置的经验。在本章的最后，读者将能够运行第一个基于 Angular 和 Priming 的 web 应用程序。

在本章中，我们将介绍以下主题：

*   打字基础
*   高级类型、装饰器和编译器选项
*   角度备忘单-关键概念概述
*   角度模块化与生命周期挂钩
*   使用 SystemJS 运行 priming
*   使用网页包设置素描项目
*   使用 Angular CLI 设置打底项目

<header>

# 打字基础

</header>

Angular 2 及更高版本具有 ECMAScript 2015/2016 和 TypeScript 的功能。新的 ECMAScript 标准针对 evergreen 浏览器，有助于编写更强大、干净、简洁的代码。您还可以在任何其他不太现代的多填充浏览器中使用这些功能，例如`core-js`（[https://github.com/zloirock/core-js [T2]。但是，为什么我们需要使用 TypeScript 呢？](https://github.com/zloirock/core-js)

打字稿（[http://www.typescriptlang.org](http://www.typescriptlang.org) 是一种类型化语言，是微软开发的一套超级 JavaScript。可以说 TypeScript 是一种高级 JavaScript，具有可选的静态类型。TypeScript 代码不是由浏览器处理的，它必须通过 TypeScript 编译器翻译成 JavaScript。这种翻译被称为*编译*或*转译*。TypeScript 编译器将`.ts`文件转换为`.js`文件。TypeScript 的主要优点如下：

*   类型可以帮助您在开发期间发现并修复许多错误。这意味着，运行时的错误更少。
*   许多现代 ECMAScript 功能都是现成支持的。根据路线图（[预计会有更多功能 https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap) ）。
*   IntelliSense 的强大工具和 IDE 支持使编码成为一种乐趣。
*   维护和重构 TypeScript 应用程序比使用非类型化 JavaScript 编写的应用程序更容易。
*   由于面向对象编程模式（如接口、类、枚举、泛型等），开发人员对 TypeScript 感到满意。
*   最后但并非最不重要的是，Angular 2+和 Priming 是用 TypeScript 编写的。

记住以下几点也很重要：

*   Typescript 语言规范说，*<q>每个 JavaScript 程序也是一个 Typescript 程序</q>*。因此，从 JavaScript 到 TypeScript 代码的迁移很容易完成。
*   即使报告了任何错误，TypeScript 编译器也会发出输出。在下一节*高级类型、装饰器和编译器选项*中，我们将看到如何禁止在错误时发出 JavaScript。

学习打字脚本语言的最好方法是什么？TypeScript 的主页上有一本官方手册，与最新发布的版本保持一致。通过打字练习场（[可以进行动手学习 http://www.typescriptlang.org/play](http://www.typescriptlang.org/play) ），它编译在浏览器中输入的即时类型脚本代码，并与生成的 JavaScript 代码并排显示：

![](assets/beff0870-ae1c-47bc-9a63-8c5e9b71e2e4.png)

或者，您可以通过在命令行中键入以下命令来全局安装 TypeScript：

```ts
npm install -g typescript

```

全局安装意味着，可以访问 TypeScript 编译器`tsc`并在您的任何项目中使用。已安装的 Node.js 和 npm 是预设的。Node.js 是 JavaScript 运行时环境（[https://nodejs.org](https://nodejs.org) ）。npm 是包管理器。它随 Node.js 一起提供，但也可以单独安装。之后，您可以通过键入以下命令将一个或多个`.ts`文件转换为`.js`文件：

```ts
tsc some.ts another.ts

```

这将产生两个文件，`some.js`和`another.js`。

<header>

# 基本类型

</header>

TypeScript 公开了基本类型以及一些额外的类型。让我们用这些例子来探索类型系统。

*   `Boolean`：类型为原始 JavaScript 布尔值：

```ts
let success: boolean = true;

```

*   `Number`：类型为原始 JavaScript 编号：

```ts
let count: number = 20;

```

*   `String`：类型为原始 JavaScript 字符串：

```ts
let message: string = "Hello world";

```

*   `Array`：类型是一个值数组。有两种等效符号：

```ts
let ages: number[] = [31, 20, 65];
let ages: Array<number> = [31, 20, 65];

```

*   `Tuple`：该类型表示一个异类值数组。`Tuple`支持存储多个不同类型的字段：

```ts
let x: [string, number];
x = ["age", 40];    // ok
x = [40, "age"] ;   // error

```

*   `Any`：类型为*任意*。当您需要描述在编写应用程序时不知道的变量类型时，它非常有用。您可以将任意类型的值分配给类型为`any`的变量。`any`类型的值可以依次分配给任意类型的变量：

```ts
let some: any = "some";
some = 10000;
some = false;

let success: boolean = some;
let count: number = some;
let message: string = some;

```

*   `Void`：该类型表示没有`any`类型。此类型通常用作函数的返回类型：

```ts
function doSomething(): void {
  // do something
}

```

*   `Nullable`：这些类型表示两种特定类型，`null`和`undefined`是每种类型的有效值。这意味着，它们可以分配给任何其他类型。这并不总是理想的。TypeScript 提供了通过将编译器选项`strictNullChecks`设置为`true`来更改此默认行为的可能性。现在，您必须使用 union 类型显式地包含[T5]类型（稍后解释），否则将出现错误：

```ts
let x: string = "foo";
x = null;    // error
let y: string | null = "foo";
y = null;    // ok

```

有时，您希望告诉编译器您比它更了解类型，并且它应该信任您。例如，假设您通过 HTTP 接收数据，并且确切地知道所接收数据的结构。编译器当然不知道这样的结构。在这种情况下，您希望在将数据分配给变量时关闭类型检查。可以使用所谓的**类型断言**。类型断言类似于其他语言中的类型转换，但不检查数据。您可以使用*角括号*或`as`语法来实现。

```ts
let element = <HTMLCanvasElement> document.getElementById('canvas');
let element = document.getElementById('canvas') as HTMLCanvasElement;

```

<header>

# 接口、类和枚举

</header>

*接口*是一种采用特定结构/形状并为其命名的方式，以便我们以后可以将其作为类型引用。它在我们的代码中定义了一个契约。接口以关键字`interface`开头。让我们举一个例子：

```ts
interface Person {
  name: string
  children?: number
  isMarried(): boolean
  (): void
}

```

指定的接口`Person`具有以下功能：

*   类型为`string`的`name`属性。
*   类型为`number`的可选属性`children`。可选属性用问号表示，可以省略。
*   返回`boolean`值的`isMarried`方法。
*   不返回任何内容的匿名（未命名）方法。

Typescript 允许您使用语法`[index: type]`指定基于`string`或`number`类型的键/值对集合。接口完全适合这样的数据结构。例如，考虑以下语法：

```ts
interface Dictionary {
  [index: number]: string
}

```

An interface is only used by TypeScript compiler at compile time, and is then removed. Interfaces don't end up in the final JavaScript output. General, no types appear in the output. You can see that in the TypeScript playground mentioned earlier.

![](assets/5f81e48d-5e0e-447b-8782-272b7fb9a4aa.png)

除了接口，还有描述对象的*类*。类充当实例化特定对象的模板。TypeScript 类的语法与 ECMAScript 2015 中本机类的语法几乎相同，只是添加了一些方便的内容。在 TypeScript 中，您可以使用`public`、`private`、`protected`和`readonly`访问修饰符：

```ts
class Dog {
  private name: string;    // can only be accessed within this class
  readonly owner: string = "Max";    // can not be modified
  constructor(name: string) {this.name = name;}
  protected sayBark() { }
}

let dog = new Dog("Sam");
dog.sayBark();  // compiler error because method 'sayBark' is protected and
                // only accessible within class 'Dog' and its subclasses.

```

省略修饰符的成员默认为`public`。如果使用`static`关键字声明属性或方法，则无需创建实例来访问它们。

类可以是抽象的，也就是说，它不能直接实例化。抽象类以关键字`abstract`开头。一个类可以实现一个接口，也可以扩展另一个类。我们可以分别使用`implements`和`extends`关键字来实现这一点。如果一个类实现了某个接口，它必须采用该接口的所有属性；否则，您将获得有关缺少属性的错误：

```ts
interface Animal {
  name: string;
}

class Dog implements Animal {
  name: string;
  // do specific things
}

class Sheepdog extends Dog {
  // do specific things    
}

```

Derived classes that contain constructor functions must call `super()`. The `super()` call executes the constructor function on the base class.

可以使用修饰符声明一个`constructor`参数。因此，将在一个位置创建并初始化成员：

```ts
class Dog {
  constructor(private name: string) { }

  // you can now access the property name by this.name
}

```

This shortened syntax is often used in Angular when we inject services into components. Angular's services are normally declared in the component's constructor with the `private` modifier.

这里提到的最后一种基本类型是*枚举*。枚举允许我们定义一组命名常量。枚举成员具有与其关联的数值（以 0 开头）：

```ts
enum Color {
  Red,
  Green,
  Blue
}

var color = Color.Red;    // color has value 0

```

<header>

# 功能

</header>

函数签名中的参数和返回值也可以键入。类型在函数执行期间保护您不受 JavaScript 错误的影响，因为当使用错误的类型时，编译器会在生成时及时警告您：

```ts
function add(x: number, y: number): number {
  return x + y;
}

```

*函数类型*是声明函数类型的一种方式。要显式声明函数类型，应使用关键字`var`或`let`、变量名、冒号、参数列表、胖箭头`=>`和函数的返回类型：

```ts
var fetchName: (division: Division, customer: Customer) => string;

```

现在，您必须提供此声明的实现：

```ts
fetchName = function (division: Division, customer: Customer): string {
  // do something
}

```

这种技术对于回调特别有用。想象一个过滤器函数，它根据某种标准过滤数组。确切的条件可以封装在作为谓词的传入回调函数中：

```ts
function filter(arr: number[], callback: (item: number) => boolean): number[] {
  let result: number[] = [];
  for (let i = 0; i < arr.length; i++) {
    if (callback(arr[i])) {
      result.push(arr[i]);
    }
  }
  return result;
}

```

具有特定回调的可能函数调用可能如下所示：

```ts
let result = filter([1, 2, 3, 4], (item: number) => item > 3);

```

在 TypeScript 中，假定每个函数参数都是必需的。有两种方法可以将参数标记为可选（调用函数时可以省略可选参数）。

*   在参数名称后使用问号：

```ts
function doSomething(param1: string, param2?: string) {
  // ...
}

```

*   使用参数的默认值（ECMAScript 2015 功能），在未提供任何值时应用该值：

```ts
function doSomething(param1: string, param2 = "some value") {
  // ...
}

```

现在，您可以只使用一个值调用此函数。

```ts
doSomething("just one value");

```

<header>

# 仿制药

</header>

在 TypeScript 中，您可以像在其他编程语言中一样定义泛型函数、接口和类。泛型函数的类型参数列在尖括号中：

```ts
function reverseAndMerge<T>(arr1: T[], arr2: T[]): T[] {
  return arr1.reverse().concat(arr2.reverse());
}

let arr1: number[] = [1, 2, 3];
let arr2: number[] = [4, 5, 6];
let arr = reverseAndMerge(arr1, arr2);

```

这样的泛型函数也可以用泛型接口定义。`reverseAndMerge`的功能签名与以下通用接口兼容：

```ts
interface GenericArrayFn<T> {
  (arr1: T[], arr2: T[]): T[];
}

let arr: GenericArrayFn<number> = reverseAndMerge;

```

请注意，尖括号中的泛型类型参数列表紧跟函数和接口的名称。对于类来说也是如此：

```ts
class GenericValue<T> {
  constructor(private value: T) { }
  increment: (x: T) => T;
  decrement: (x: T) => T;
}

let genericValue = new GenericValue<number>(5);
genericValue.increment = function (x) {return ++x;};
genericValue.decrement = function (x) {return --x;};

```

<header>

# 模块

</header>

ECMAScript 2015 引入了内置模块。模块的特点如下：

*   每个模块都在自己的文件中定义。
*   在模块中定义的函数或变量在外部不可见，除非您显式导出它们。
*   您可以将[T0]关键字放在任何变量、函数或类声明的前面，以便将其从模块中导出。
*   您可以使用`import`关键字使用导出的变量、函数或类声明。
*   模块是单例的。一个模块只有一个实例存在，即使它被导入了多次。

此处列出了一些导出可能性：

```ts
// export data
export let color: string = "red";

// export function
export function sum(num1: number, num2: number) {
  return num1 + num1;
}

// export class
export class Rectangle {
  constructor(private length: number, private width: number) { }
}

```

您可以声明变量、函数或类，然后将其导出。您还可以使用`as`关键字重命名导出。新名称是用于导入的名称：

```ts
class Rectangle {
  constructor(private height: number, private width: number) { }
}

export {Rectangle as rect};

```

一旦您有了带有导出的模块，您就可以使用`import`关键字在另一个模块中访问其功能：

```ts
import {sum} from "./lib.js";
import {Rect, Circle} from "./lib.js";

let sum = sum(1, 2);
let rect = new Rect(10, 20);

```

有一种特殊情况允许您将整个模块作为单个对象导入。所有导出的变量、函数和类都可以作为属性在该对象上使用：

```ts
import * as lib from "./lib.js";

let sum = lib.sum(1, 2);

```

可以使用`as`关键字重命名导入，并在新名称下使用：

```ts
import {sum as add} from "./lib.js";

let sum = add(1, 2);

```

<header>

# 高级类型、装饰器和编译器选项

</header>

TypeScript 有更多的类型和高级构造，如装饰器和类型定义文件。本章概述高级主题，并说明如何自定义编译器配置。

<header>

# 联合类型和类型别名

</header>

*联合类型*描述了一个可以是多种类型之一的值。垂直条`|`用作该值可以具有的每种类型的分隔符。例如，`number | string`是值的类型，可以是数字或字符串。对于这些值，我们只能访问联合中所有类型的通用成员。以下代码之所以有效，是因为字符串和数组上都存在[T2]属性：

```ts
var value: string | string[] = 'some';
let length = value.length;

```

下一个代码段给出错误，因为`Bike`类型上不存在`model`属性：

```ts
interface Bike {
  gears: number;
}

interface Car {
  gears: number;
  model: string;
}

var transport: Bike | Car = {gears: 1};
transport.model = "Audi";    // compiler error

```

*类型别名*用作现有类型或类型组合的替代名称。它不会创建新类型。类型别名以[T0]关键字开头。

```ts
type PrimitiveArray = Array<string|number|boolean>;
type Callback = () => number;
type PrimitiveArrayOrCallback = PrimitiveArray | Callback;

```

类型别名可以用于更好的代码可读性，例如，在函数参数列表中。

```ts
function doSomething(n: PrimitiveArrayOrCallback): number {
  ...
}

```

类型别名也可以是泛型的，并且可以生成复杂的类型，这是接口无法生成的。

<header>

# 类型推断

</header>

当没有明确提供类型时，使用*类型推断*。例如，在以下陈述中：

```ts
var x = "hello";
var y = 99;

```

它们没有显式的类型注释。TypeScript 可以推断出`x`是一个字符串，`y`是一个数字。如您所见，如果编译器能够推断出该类型，则可以省略该类型。TypeScript 不断改进类型推断。当数组中存在多个类型的元素时，它会尝试猜测一个最佳公共类型。以下变量`animal`的类型，其中`Sheepdog extends Dog`为`Dog[]`：

```ts
let animal = [new Dog(), new Sheepdog()];

```

下一个数组最常见的类型是`(Dog | Fish)[]`，因为类`Fish`没有扩展到任何其他类：

```ts
class Fish {
  kind: string;
}

let animal = [new Dog(), new Sheepdog(), new Fish()];

```

类型推断也用于函数。在下一个示例中，编译器可以计算出函数参数（`string`的类型和返回值（`boolean`）：

```ts
let isEmpty: (param: string) => boolean;
isEmpty = function(x) {return x === null || x.length === 0};

```

<header>

# 装饰师

</header>

ECMAScript 2016（[中提出了*装饰师*https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators) ）。它们类似于 Java 注释——它们还向类声明、方法、属性和函数的参数添加元数据，但功能更强大。他们向目标添加新行为。使用 decorator，我们可以在目标执行之前、之后或周围运行任意代码，就像在面向方面编程中一样，甚至可以用新定义替换目标。在 TypeScript 中，可以修饰构造函数、方法、属性和参数。每个 decorator 都以[T0]字符开头，后跟 decorator 的名称。

它是如何在以目标为参数的情况下工作的？让我们实现一个具有日志功能的经典示例。我们想实现一个方法修饰符`@log`。方法装饰器接受三个参数：定义方法的类的实例、属性的键和属性描述符（[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty [T2]。](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

如果方法装饰器返回一个值，它将用作此方法的新属性描述符：

```ts
const log = (target: Object, key: string | symbol, descriptor: PropertyDescriptor) => {
  // save a reference to the original method
  var originalMethod = descriptor.value;
  // replace the original function
  descriptor.value = function(...args: any[]) {
    console.log("Arguments: ", args.join(", "));
    const result = originalMethod.apply(target, args);
    console.log("Result: ", result);
    return result;
  }
  return descriptor;
}

class Rectangle {
  @log
  area(height: number, width: number) {
    return height * width;
  }
}

let rect = new Rectangle();
let area = rect.area(2, 3);

```

此装饰器记录收到的参数和返回值。装饰器也可以用参数组合和定制。例如，您可以编写以下内容：

```ts
class Rectangle {
  @log("debug")
  @persist("localStorage")
  area(height: number, width: number) {
    return height * width;
  }
}

```

Angular 提供了不同类型的装饰器，用于在编译时注入依赖项或添加元数据信息：

*   类装饰器，如`@NgModule`、`@Component`和`@Injectable`
*   [T0]和[T1]等房地产装饰师
*   方法装饰器，如`@HostListener`
*   参数修饰符，如`@Inject`

TypeScript 编译器能够为装饰器发出一些设计时类型元数据。要访问此信息，我们必须安装一个名为`reflect-metadata`的 Polyfill：

```ts
npm install reflect-metadata --save

```

例如，现在我们可以访问`target`对象上的属性类型（`key`），如下所示：

```ts
let typeOfKey = Reflect.getMetadata("design:type", target, key);

```

Refer to the official TypeScript documentation to learn more about decorators and reflect metadata API ([http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)). In TypeScript, Angular applications, decorators are enabled by setting the compiler options `emitDecoratorMetadata` and `experimentalDecorators` to `true` (compiler options are described later on).

<header>

# 类型定义文件

</header>

用本机 JavaScript 编写的 JavaScript 程序没有任何类型信息。如果向基于 TypeScript 的应用程序添加 jQuery 或 Lodash 之类的 JavaScript 库并尝试使用它，TypeScript 编译器可以找到任何类型信息并警告您编译错误。编译时安全性、类型检查和上下文感知代码完成丢失。这就是*类型定义文件*发挥作用的地方。

类型定义文件为非静态类型的 JavaScript 代码提供类型信息。类型定义文件以`.d.ts`结尾，仅包含不是由 TypeScript 发出的定义。`declare`关键字用于向存在于某处的 JavaScript 代码添加类型。让我们举个例子。TypeScript 随附描述 ECMAScript API 的`lib.d.ts`库。此类型定义文件由 TypeScript 编译器自动使用。此文件中定义了以下声明，但没有实现详细信息：

```ts
declare function parseInt(s: string, radix?: number): number;

```

现在，当您在代码中使用[T0]函数时，TypeScript 编译器会确保您的代码使用正确的类型，并且 IDE 会在您编写代码时显示上下文相关提示。通过键入以下命令，可以将类型定义文件作为依赖项安装在`node_modules/@types`目录下：

```ts
npm install @types/<library name> --save-dev

```

jQuery 库的一个具体示例是：

```ts
npm install @types/jquery --save-dev

```

In Angular, all type definition files are bundled with Angular npm packages and located under `node_modules/@angular`. There is no need to install such files separately like we did for jQuery. TypeScript finds them automatically.

大多数情况下，您的编译目标是 ES5（生成的 JavaScript 版本，受到广泛支持），但您希望通过添加 polyfill 来使用一些 ES6（ECMAScript 2015）功能。在这种情况下，您必须告诉编译器应该在`lib.es6.d.ts`或`lib.es2015.d.ts`文件中查找扩展定义。这可以通过以下设置在编译器选项中实现：

```ts
"lib": ["es2015", "dom"]

```

<header>

# 编译器选项

</header>

通常，新的 TypeScript 项目的第一步是添加一个`tsconfig.json`文件。该文件定义项目和编译器设置，例如，编译中要包含的文件和库、输出结构、模块代码生成等。`tsconfig.json`中角 2+项目的典型配置如下所示：

```ts
{
  "compilerOptions": {
    "target": "es5",
    "module": "es2015",
    "moduleResolution": "node",
    "noImplicitAny": true,
    "sourceMap": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "outDir": "dist",
    "lib": ["es2015", "dom"]
  },
  "types": ["node"],
  "exclude": ["node_modules", "dist"]
}

```

列出的编译器设置描述如下。所有选项的完整列表可在 TypeScript 文档页面（[中找到 https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html) ）。

| **选项** | **型** | **违约** | **说明** |
| `target` | `string` | `ES3` | 这指定了 ECMAScript 目标版本：`ES3`、`ES5`、`ES2015`、`ES2016`和`ES2017`。 |
| `module` | `string` | `ES6`如果目标为“ES6”，则为`CommonJS`否则 | 指定模块代码生成的格式：`None`、`CommonJS`、`AMD`、`System`、`UMD`、`ES6`或`ES2015`。 |
| `moduleResolution` | `string` | `Classic`如果模块为“AMD”，则为`System`、`ES6`、`Node`否则 | 这决定了如何解析模块。`Node`用于 Node.js 样式解析或`Classic`。 |
| `noImplicitAny` | `boolean` | `false` | 这会在具有隐含的[T0]类型的表达式和声明上引发错误。 |
| `sourceMap` | `boolean` | `false` | 这将生成相应的`.map`文件。如果要调试原始文件，这非常有用。 |
| `emitDecoratorMetadata` | `boolean` | `false` | 这将为源代码中的修饰声明发出设计类型元数据。如果要使用 Angular 开发 web 应用程序，必须将该值设置为`true`。 |
| `experimentalDecorators` | `boolean` | `false` | 这使 ECMAScript 装饰器的实验性支持成为可能。如果要使用 Angular 开发 web 应用程序，必须将该值设置为`true`。 |
| `outDir` | `string` | - | 这是已编译文件的输出目录。 |
| `lib` | `string[]` | 有关更多信息，请参阅文档。 | 这是要包含在编译中的库文件列表。有关更多信息，请参阅文档。 |
| `types` | `string[]` | - | 这是要包括的类型定义的名称列表。 |
| `exclude` | `string[]` | - | 这是从编译中排除的（子）目录列表。 |

You can stop the compiler from emitting JavaScript on errors by setting the `--noEmitOnError` option to `true`.

<header>

# 角度备忘单-关键概念概述

</header>

Angular 2 为构建 web 应用程序引入了全新的概念。新的角度平台是复杂的。无法详细解释许多角度特征。相反，我们将集中讨论最重要的关键概念，如依赖项注入、组件以及它们之间的通信、内置指令、服务、模板语法、表单和路由。

<header>

# 组件、服务和依赖注入

</header>

通常，您可以编写角度应用程序，方法是使用角度特定的标记和组件类组合 HTML 模板来管理这些模板。**组件**只是一个用`@Component`注释的类型脚本类。`@Component`修饰符用于定义关联的元数据。它需要具有以下最常用属性的对象：

*   `selector`：这是表示该组件的 HTML 标记的名称
*   `template`：这是一个内联定义的模板，具有视图的 HTML/角度标记
*   `templateUrl`：模板所在的外部文件路径
*   `styles`：应用于此组件视图的内联定义样式
*   `styleUrls`：指向外部文件的路径数组，其样式将应用于该组件的视图
*   `providers`：此组件及其子组件可用的提供程序数组
*   `exportAs`：组件实例在模板中导出时使用的名称
*   `changeDetection`：这是该组件使用的变更检测策略
*   `encapsulation`：这是该组件使用的样式封装策略

组件类通过属性和方法的 API 与视图交互。组件类应该将复杂任务委托给业务逻辑所在的服务。**服务**只是实例化然后注入组件的类。如果在根组件级别注册服务，它们将充当单例并跨多个组件共享数据。在下一节*角模块化和生命周期挂钩*中，我们将看到如何注册服务。下面的示例演示如何使用组件和服务。我们将编写一个服务类`ProductService`，然后在`ProductComponent`的构造函数中指定一个类型为`ProductService`的参数。Angular 将自动将该服务注入组件：

```ts
import {Injectable, Component} from '@angular/core';

@Injectable()
export class ProductService {
  products: Product[];

  getProducts(): Array<Product> {
    // retrieve products from somewhere...
    return products;
  }
}

@Component({
  selector: 'product-count',
  template: `<h2 class="count">Found {{products.length}} products</h2>`,
  styles: [`
    h2.count {
      height: 80px;
      width: 400px;
    }
  `]
})
export default class ProductComponent {
  products: Product[] = [];

  constructor(productService: ProductService) {
    this.products = productService.getProducts();
  }
}

```

Notice that we applied the `@Injectable()` decorator to the service class. This is necessary for emitting metadata that Angular needs to inject other dependencies into this service. Using `@Injectable` is a good programming style even if you don't inject other services into your service.

知道`providers`数组中的项目是什么样子很好。项是具有`provide`属性（用于依赖项注入的符号）和提供实现细节的三个属性`useClass`、`useFactory`或`useValue`之一的对象：

```ts
{provide: MyService, useClass: MyMockService}
{provide: MyService, useFactory: () => {return new MyMockService()}}
{provide: MyValue, useValue: 50}

```

<header>

# 模板和绑定

</header>

模板告诉您如何渲染组件的视图。模板是带有特定 Angular 模板语法的 HTML 片段，例如插值、属性、属性和事件绑定、内置指令和管道（仅举几例）。我们将从插值开始快速概述模板语法。**插值**用于计算双花括号中的表达式。然后，求值表达式将转换为字符串。表达式可以包含任何数学计算、组件的属性和方法，以及更多内容：

```ts
<p>Selected car is {{currentCar.model}}</p>

```

Angular 在每个更改检测周期后计算模板表达式。更改检测周期由许多异步活动触发，如 HTTP 响应、按键和鼠标事件等。下一个基本模板语法与各种绑定相关。*属性绑定*将元素属性设置为组件属性值。元素属性在方括号中定义：

```ts
<img [src]="imageUrl">
<button [disabled]="formValid">Submit</button>

```

这里，`imageUrl`和`formValid`是组件的属性。请注意，这是一个*单向*绑定，因为数据流发生在一个方向上，从组件属性到目标元素属性。*属性绑定*允许我们设置属性。这种绑定在没有要绑定的元素属性时使用。属性绑定也使用方括号。属性名称本身用 Adple T2T 前缀，例如，考虑 AARS 属性用于 Web 可访问性：

```ts
<button [attr.aria-expanded]="expanded" [attr.aria-controls]="controls">
  Click me
</button>

```

用户交互导致从元素到组件的数据流。在 Angular 中，我们可以通过*事件绑定*来监听某些按键、鼠标和触摸事件。事件绑定语法由左侧括号内的目标事件名称和右侧带引号的模板语句组成。特别是，您可以调用组件的方法。在下一个代码段中，单击即可调用[T0]方法：

```ts
<button (click)="onSave()">Save</button>

```

该方法（通常是模板语句）获取一个参数——一个名为`$event`的事件对象。对于本机 HTML 元素和事件，`$event`是一个 DOM 事件对象：

```ts
<input [value]="name" (input)="name=$event.target.value">

```

双向绑定也是可能的。`[(value)]`语法将属性绑定的括号与事件绑定的括号结合起来。Angular 的指令`NgModel`最适合于本机或自定义输入元素的双向绑定。考虑以下样本：

```ts
<input [(ngModel)]="username">

```

相当于：

```ts
<input [value]="username" (input)="username=$event.target.value">

```

简单地说，双向绑定：当用户进行更改时，属性会同时显示和更新。*模板参考变量*是方便模板语法的另一个示例。您可以在任何 DOM 元素上声明具有哈希符号（`#`的变量，并在模板中的任何位置引用该变量。下一个示例显示在`input`元素上声明的`username`变量。此参考变量在按钮上使用——用于获取`onclick`处理程序的输入值：

```ts
<input #username>
<button (click)="submit(username.value)">Ok</button>

```

模板引用变量也可以设置为指令。一个典型的例子是[T0]指令，它提供了有关[T1]元素的有用细节。例如，如果表单无效（未填写必填字段等），可以禁用“提交”按钮：

```ts
<form #someForm="ngForm">
  <input name="name" required [(ngModel)]="name">
  ...
  <button type="submit" [disabled]="!someForm.form.valid">Ok</button>
</form>

```

最后但并非最不重要的是，*管道*操作员（`|`。它用于转换表达式的结果。管道操作符将左侧表达式的结果传递给右侧的管道函数。例如，管道`date`根据指定的格式（[对 JavaScript`Date`对象进行格式化 https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html](https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html) ：

```ts
Release date: {{releaseDate | date: 'longDate'}}
// Output: "August 30, 2017"

```

也可以应用多个链式管道。

<header>

# 内置指令

</header>

Angular 有很多内置指令：`ngIf`、`ngFor`、`ngSwitch`、`ngClass`和`ngStyle`。前三个指令称为*结构指令*，用于转换 DOM 的结构。结构指令以星号（`*`开头）。最后两个指令动态操作 CSS 类和样式。让我们解释一下示例中的指令。

[T0]指令根据表达式的布尔结果在 DOM 中添加和删除元素。在下一个代码段中，`show`属性的计算结果为`false`时，`<h2>ngIf</h2>`被删除，否则重新创建：

```ts
<div *ngIf="show">
  <h2>ngIf</h2>
</div>

```

Angular 4 引入了一个新的`else`子句，其中引用了`ng-template`定义的模板名称。当`ngIf`条件评估为`false`时，显示`ng-template`内的内容：

```ts
<div *ngIf="showAngular; else showWorld">
  Hello Angular
</div>
<ng-template #showWorld>
  Hello World
</ng-template>

```

`ngFor`通过迭代数组输出元素列表。在下一个代码片段中，我们迭代[T1]数组，并将每个项存储在名为[T2]的模板变量中。然后可以在模板中访问此变量：

```ts
<ui>
  <li *ngFor="let person of people">
    {{person.name}}
  </li>
</ui>

```

`ngSwitch`根据条件有条件地交换内容。在下一个代码段中，`ngSwitch`绑定到`choice`属性。如果`ngSwitchCase`与此属性的值匹配，则显示相应的 HTML 元素。如果不存在匹配，则显示与`ngSwitchDefault`关联的元素：

```ts
<div [ngSwitch]="choice">
  <h2 *ngSwitchCase="'one'">One</h3>
  <h2 *ngSwitchCase="'two'">Two</h3>
  <h2 *ngSwitchDefault>Many</h3>
</div>

```

`ngClass`在元素上添加和删除 CSS 类。指令应该接收一个对象，该对象的类名作为键，表达式作为值，计算结果为`true`或`false`。如果值为`true`，则将关联的类添加到元素中。否则，如果`false`，则从元素中移除该类：

```ts
<div [ngClass]="{selected: isSelected, disabled: isDisabled}">

```

`ngStyle`添加和删除元素上的内联样式。该指令应接收一个对象，该对象的样式名称作为键，表达式作为值计算为样式值。一个键可以有一个可选的`.<unit>`后缀（例如`top.px`：

```ts
<div [ngStyle]="{'color': 'red', 'font-weight': 'bold', 'border-top': borderTop}">

```

In order to be able to use built-in directives in templates, you have to import `CommonModule` from `@angular/common` and add it to the root module of your application. Angular's modules are explained in the next chapter.

<header>

# 组件之间的通信

</header>

组件可以以松散耦合的方式相互通信。Angular 的组件可以通过多种方式共享数据，包括：

*   使用`@Input()`将数据从父级传递给子级
*   使用`@Output()`将数据从子级传递到父级
*   使用服务进行数据共享
*   呼叫`ViewChild`、`ViewChildren`、`ContentChild`、`ContentChildren`
*   使用局部变量与子组件交互

我们将仅描述前三种方式。组件可以声明输入和输出属性。要将数据从父组件传递到子组件，父组件将值绑定到子组件的输入属性。子对象的输入属性应该用`@Input()`装饰。让我们创建`TodoChildComponent`：

```ts
@Component({
  selector: 'todo-child',
  template: `<h2>{{todo.title}}</h2>`
})
export class TodoChildComponent {
  @Input() todo: Todo;
}

```

现在，父组件可以在其模板中使用`todo-child`，并将父组件的`todo`对象绑定到子组件的`todo`属性。孩子的财产像往常一样放在方括号内：

```ts
<todo-child [todo]="todo"></todo-child>

```

如果组件需要将数据传递给其父级，它将通过输出属性发出自定义事件。父级可以创建特定组件事件的侦听器。让我们来看看它的实际效果。子组件`ConfirmationChildComponent`公开了一个用`@Output()`修饰的`EventEmitter`属性，当用户点击按钮时会发出事件：

```ts
@Component({
  selector: 'confirmation-child',
  template: `
    <button (click)="accept(true)">Ok</button>
    <button (click)="accept(false)">Cancel</button>
  `
})
export class ConfirmationChildComponent {
  @Output() onAccept = new EventEmitter<boolean>();

  accept(accepted: boolean) {
    this.onAccept.emit(accepted);
  }
}

```

父级向该事件属性订阅事件处理程序，并对发出的事件作出反应：

```ts
@Component({
  selector: 'confirmation-parent',
  template: `
    Accepted: {{accepted}}
    <confirmation-child (onAccept)="onAccept($event)"></confirmation-child>
  `
})
export class ConfirmationParentComponent {
  accepted: boolean = false;

  onAccept(accepted: boolean) {
    this.accepted = accepted;
  }
}

```

可以通过服务进行双向通信。角度杠杆 RxJS 库（[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS) ）用于应用程序多个部分之间以及应用程序与远程后端之间的异步和基于事件的通信。异步和基于事件的通信中的关键概念是`Observer`和`Observable`。它们为基于推送的通知提供了一种通用机制，也称为观察者设计模式。`Observable`表示发送通知的对象，`Observer`表示接收通知的对象。

Angular 在任何地方都实现了这种设计模式。例如，Angular 的`Http`服务返回一个`Observable`对象：

```ts
constructor(private http: Http) {}

getCars(): Obvervable<Car[]> {
  return this.http.get("../data/cars.json")
    .map(response => response.json().data as Car[]);
}

```

在组件间通信的情况下，可以使用`Subject`类的实例。此类同时继承了`Observable`和`Observer`。这意味着它充当消息总线。让我们实现允许我们发射和接收`Todo`对象的`TodoService`：

```ts
@Injectable()
export class TodoService {
  private subject = new Subject();

  toggle(todo: Todo) {
    this.subject.next(todo);
  }

  subscribe(onNext, onError, onComplete) {
    this.subject.subscribe(onNext, onError, onComplete);
  }
}

```

组件可以通过以下方式使用此服务：

```ts
export class TodoComponent {
  constructor(private todosService: TodosService) {}

  toggle(todo: Todo) {
    this.todosService.toggle(todo);
  }
}

export class TodosComponent {
  constructor(private todosService: TodosService) {
    todosService.subscribe(
      function(todo: Todo) { // TodoComponent sent todo object },
      function(e: Error) { // error occurs },
      function() { // completed }
    );
  }
}

```

<header>

# 形式

</header>

表单是每个 web 应用程序的主要构建块。Angular 提供了两种构建表单的方法：*模板驱动表单*和*反应表单*。本节简要介绍模板驱动的表单。

Reactive forms are suitable when you need to create dynamic forms programmatically in the component's class. Refer to the official Angular documentation to learn reactive forms ([https://angular.io/docs/ts/latest/guide/reactive-forms.html](https://angular.io/docs/ts/latest/guide/reactive-forms.html)).

我们已经提到了两个指令：`NgForm`和`NgModel`。第一个指令创建一个`FormGroup`实例并将其绑定到表单，以便跟踪聚合表单值和验证状态。第二个创建一个`FormControl`实例并将其绑定到相应的`form`元素。`FormControl`实例跟踪`form`元素的值和状态。每个输入元素都应该有一个`name`属性，该属性是`FormGroup`在分配给`name`属性的名称下注册`FormControl`所必需的。如何处理这些跟踪数据？您可以将`NgForm`和`NgModel`指令分别导出到本地模板变量中，如`#f="ngForm"`和`#i="ngModel"`。这里，`f`和`i`是本地模板变量，分别允许您访问`FormGroup`和`FormControl`的值和状态。这是可能的，因为指令本身重复了来自`FormGroup`和`FormControl`的属性。有了这些知识，您现在可以检查整个表单或特定的`form`元素：

*   有效（`valid`和`invalid`属性）
*   已参观过（`touched`和`untouched`酒店）
*   具有一些更改的值（`dirty`和`pristine`属性）

下一个示例说明了基本概念：

```ts
<form #f="ngForm" (ngSubmit)="onSubmit(f)" novalidate>
  <label for="name">Name</label>
  <input type="text" id=name" name="name" required
         [(ngModel)]="name" #i="ngModel"> 
  <div [hidden]="i.valid || i.pristine">
    Name is required
  </div>
  <button>Submit</button>
</form>

// Output values and states
Input value: {{i.value}}
Is input valid? {{i.valid}}
Input visited? {{i.touched}}
Input value changed? {{i.dirty}}
Form input values: {{f.value | json}}
Is form valid? {{f.valid}}
Form visited? {{f.touched}}
Form input values changed? {{f.dirty}}

```

[T0]指令还使用反映元素状态的特定 CSS 类更新相应的[T1]元素。根据当前状态添加/删除以下类：

| **状态** | **类如果为真** | **类如果为假** |
| 元素已被访问 | `ng-touched` | `ng-untouched` |
| 元素的值已更改 | `ng-dirty` | `ng-pristine` |
| 元素的值是有效的 | `ng-valid` | `ng-invalid` |

这是方便的造型。例如，如果出现验证错误，可以在输入元素周围设置红色边框：

```ts
input.ng-dirty.ng-invalid {
  border: solid 1px red;
}

```

<header>

# 路由

</header>

Angular 的`router`模块允许您在单页应用程序中配置导航，而无需重新加载整页。路由器可以在一个名为`<router-outlet>`的特殊标记内显示不同的视图（编译组件模板）。在导航过程中，一个视图将被另一个视图替换。简单的路由配置如下所示：

```ts
const router: Routes = [
  {path: '', redirectTo: 'home', pathMatch: 'full'},
  {path: 'home', component: HomeComponent},
  {path: 'books', component: BooksComponent}
];

```

当您导航到 web 上下文根目录时，您将被重定向到`/home`。作为对此的反应，`HomeComponent`的视图将显示在`<router-outlet>`中。很明显，直接导航到`/home`会显示相同的视图。指向`/books`的导航显示`BooksComponent`的视图。此类路由器配置应通过`RouterModule.forRoot`转换为 Angular 的模块：

```ts
const routes: ModuleWithProviders = RouterModule.forRoot(router);

```

然后将其导入根模块类中。除了根模块外，Angular 应用程序还可以由许多功能模块或延迟加载的模块组成。这些单独的模块可以有自己的路由器配置，这些配置应转换为 Angular 的模块，带有`RouterModule.forChild(router)`。下一节，*角度模块化和生命周期挂钩，*详细讨论了模块。Angular 为实现客户端导航提供了两种策略：

*   `HashLocationStrategy`：此策略向基本 URL 添加哈希符号（`#`）。此符号后的所有内容都表示浏览器 URL 的哈希片段。散列片段标识路由。例如，[T2]。更改路由不会导致服务器端请求。相反，Angular 应用程序将导航到新的路由和视图。此策略适用于所有浏览器。
*   `PathLocationStrategy`：此策略基于**历史 API**，仅适用于支持 HTML5 的浏览器。这是默认的位置策略。

细节将在这里提及。如果要使用`HashLocationStrategy`，需要从`'@angular/common'`导入`LocationStrategy`和`HashLocationStrategy`两个类，并按照如下方式配置提供者：

```ts
providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]

```

提供者将在下一节*角度模块化和生命周期挂钩中介绍。*类需要为整个应用程序配置基本 URL。最佳做法是从`'@angular/common'`导入`APP_BASE_HREF`常量，并将其用作提供程序，以便配置基本 URL：

```ts
providers: [{provide: APP_BASE_HREF, useValue: '/'}]

```

如何触发导航？您可以通过两种方式实现这一点，一种是通过具有`routerLink`属性的链接，该属性指定由路由（路径）和可选参数组成的数组：

```ts
<a [routerLink]="['/']">Home</a>
<a [routerLink]="['/books']">Books</a>

<router-outlet></router-outlet>

```

或者通过编程方式，在 Angular 的`Router`服务上调用`navigate`方法：

```ts
import {Router} from '@angular/router';

...

export class HomeComponent {

  constructor(private router: Router) { }

  gotoBooks() {
    this.router.navigate(['/books']);
  }
}

```

还可以将参数传递给管线。参数的占位符以冒号（`:`开头）：

```ts
const router: Routes = [
  ...
  {path: 'books/:id', component: BookComponent}
];

```

现在，当导航到具有真实参数的书籍时，例如，以编程方式作为`this.router.navigate(['/books/2'])`，真实参数可以通过`ActivatedRoute`访问：

```ts
import {ActivatedRoute} from '@angular/router';

...

export class BooksComponent {
  book: string;

  constructor(private route: ActivatedRoute) {
    this.book = route.snapshot.params['id'];
  }
}

```

路由器出口也可以命名为：

```ts
<router-outlet name="author"></router-outlet>

```

相关配置应包含带有路由器出口名称的`outlet`属性：

```ts
{path: 'author', component: AuthorComponent, outlet: 'author'}

```

<header>

# 角度模块化与生命周期挂钩

</header>

NgModules 的角度模块化为在 web 应用程序中组织代码提供了一种很好的方法。许多第三方库，如 Priming、Angular Material、Ionic，都是作为 NgModules 分发的。*生命周期挂钩*允许我们在定义明确的时间在组件级别执行自定义逻辑。本节详细介绍了这些主要概念。

<header>

# 模块和引导

</header>

Angular 模块可以将组件、指令、服务、管道等整合到内聚的功能块中。Angular 的代码是模块化的。每个模块都有自己的功能。有`FormsModule`、`HttpModule`、`RouterModule`等多个模块。模块是什么样子的？模块是一个用`@NgModule`装饰符（从`@angular/core`导入）注释的类。`@NgModule`获取一个配置对象，告诉 Angular 如何编译和运行模块代码。配置对象最重要的属性是：

*   `declarations`：包含组件、指令和管道的数组，这些组件、指令和管道在该模块中实现并属于该模块。
*   `imports`：以其他模块的形式存在依赖关系的数组，需要提供给该模块。
*   `exports`：要导出和允许其他模块导入的组件、指令和管道的数组。其余的都是私人的。这是模块的公共 API，类似于 ECMAScript 模块中的[T1]关键字的工作方式。
*   `providers`：这是该模块中可用的服务数组（服务类、工厂或值）。提供程序是模块的一部分，可以注入模块内定义的组件（包括子组件）、指令和管道中。
*   `bootstrap`：每个角度应用程序至少有一个模块——根模块。`bootstrap`属性仅在根模块中使用，包含启动应用程序时应首先实例化的组件。
*   `entryComponents`：这是 Angular 为其生成组件工厂的组件数组。通常，如果要在运行时动态创建组件，则需要将其注册为入口组件。在模板编译时，这些组件不能通过 Angular 自动计算出来。

本书中任何单独示例的典型模块配置如下所示：

```ts
import {NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
import {FormsModule} from '@angular/forms';
import {APP_BASE_HREF} from '@angular/common';

// PrimeNG modules needed in this example
import {ButtonModule} from 'primeng/components/button/button';
import {InputTextModule} from 'primeng/components/inputtext/inputtext';

import {AppComponent} from './app.component';
import {SectionComponent} from './section/section.component';
import {routes} from './app-routing.module';

@NgModule({
  imports: [BrowserModule, BrowserAnimationsModule, FormsModule,
            routes, ButtonModule, InputTextModule],
  declarations: [AppComponent, SectionComponent],
  providers: [{provide: APP_BASE_HREF, useValue: '/'}],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

`BrowserModule` is needed to get access to the browser-specific renderers and Angular standard directives such as `ngIf` and `ngFor`. Don't import `BrowserModule` in any other modules except the root module. Feature modules and lazy-loaded modules should import `CommonModule` instead.

以下是如何在 JIT 模式下引导 Angular 应用程序（即时编译）的示例：

```ts
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';
import {AppModule} from './app';

platformBrowserDynamic().bootstrapModule(AppModule);

```

在**提前**模式下（**AOT**编译），需要提供工厂类。要生成工厂类，必须运行`ngc`编译器而不是 TypeScript`tsc`编译器。在本章的最后两节中，您将看到如何将 AOT 与 Webpack 和 Angular CLI 一起使用。AOT 模式下的引导代码如下所示：

```ts
import {platformBrowser} from '@angular/platform-browser';
import {AppModuleNgFactory} from './app.ngfactory';

platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);

```

Templates with bindings written in Angular need to be compiled. With AOT, the compiler runs once at build time. With JIT, it runs every time at runtime. Browsers load a pre-compiled version of the application much faster and there is no need to download the Angular compiler if the app is already compiled.

模块也可以在收到请求时（按需）延迟加载。这种方法减少了初始页面显示时加载的 web 资源的大小。页面显示得更快。如果要启用延迟加载，必须将路由器配置为延迟加载模块。您只需要一个具有`loadChildren`属性的`path`对象，它指向延迟加载模块的路径和名称：

```ts
{path: "section", loadChildren: "app/section/section.module#SectionModule"}

```

注意，`loadChildren`属性的值是一个字符串。此外，导入此路由器配置的模块不应在配置对象的`imports`属性中将延迟加载的模块声明为依赖项。

<header>

# 生命周期挂钩

</header>

角度组件带有生命周期挂钩，在组件生命周期中的特定时间执行。为此，Angular 提供了不同的接口。每个接口都有一个与前缀为`ng`的接口名同名的方法。每个方法都在相应的生命周期事件发生时执行。它们也称为生命周期挂钩方法。Angular 在调用构造函数后按以下顺序调用生命周期挂钩方法：

| **生命周期挂钩方法** | **目的和时机** |
| `ngOnChanges` | 只要一个或多个数据绑定输入属性发生更改，就会调用此函数。初始更改（在`ngOnInit`之前）和任何其他后续更改时调用此方法。此方法有一个参数——一个具有类型为`string`的键和类型为`SimpleChange`的值的对象。键是组件的属性名称。`SimpleChange`对象包含当前值和以前的值。下面将显示一个使用示例。 |
| `ngOnInit` | 在第一个`ngOnChanges`之后调用一次。请注意，组件的构造函数应仅用于依赖项注入，因为构造函数中尚未设置数据绑定输入值。其他所有东西都应该移到`ngOnInit`挂钩上。下面将显示一个使用示例。 |
| `ngDoCheck` | 这在每次更改检测运行期间都被调用。这是自定义逻辑的好地方，它允许我们对对象上的哪些属性发生了更改进行细粒度检查。 |
| `ngAfterContentInit` | 在 Angular 将外部内容放入组件视图后，将调用此函数一次。任何外部内容的占位符都标有`ngContent`指令（`ng-content`标记）。[T2]指令的使用示例将在后面演示。 |
| `ngAfterContentChecked` | 这是在角度检查放入组件视图的内容后调用的。 |
| `ngAfterViewInit` | 在 Angular 初始化组件和子视图后，将调用此函数一次。 |
| `ngAfterViewChecked` | 这是在对零部件的视图和子视图进行角度检查后调用的。 |
| `ngOnDestroy` | 这是在 Angular 销毁组件实例之前调用的。当您使用内置的结构指令（如[T0]、[T1]、[T2]）删除组件时，或者当您导航到另一个视图时，会发生这种情况。这是一个很好的清理操作的地方，例如取消订阅观测值、分离事件处理程序、取消间隔计时器等等。 |

让我们看一个如何使用`ngOnInit`和`ngOnChanges`的示例：

```ts
import {Component, OnInit, OnChanges, SimpleChange} from '@angular/core';

@Component({
  selector: 'greeting-component',
  template: `<h1>Hello {{text}}</h1>`
})
export class GreetingComponent implements OnInit, OnChanges {
  @Input text: string;

  constructor() { }

  ngOnInit() {
    text = "Angular";
  }

  ngOnChanges(changes: {[propertyName: string]: SimpleChange}) {
    console.log(changes.text);
    // changes = {'text': {currentValue: 'World', previousValue: {}}}
    // changes = {'text': {currentValue: 'Angular', 
                  previousValue: 'World'}}
  }
}

```

HTML 中的用法：

```ts
<greeting-component [text]="World"></greeting-component>

```

现在让我们看看如何使用[T0]指令：

```ts
export @Component({
  selector: 'greeting-component',
  template: `<div><ng-content></ng-content> {{text}}</div>`
})
class GreetingComponent {
  @Input text: string;
}

```

HTML 中的用法：

```ts
<greeting-component [text]="World"><b>Hello</b></greeting-component>

```

组件初始化后，每次变更检测运行都会执行以下钩子方法：`ngDoCheck`->`ngAfterContentChecked`->`ngAfterViewChecked`->`ngOnChanges`。

<header>

# 使用 SystemJS 运行 priming

</header>

涂底漆（[https://www.primefaces.org/primeng](https://www.primefaces.org/primeng) 是 Angular 2+丰富 UI 组件的开源库。PrimeNG 源于 PrimeFaces——最流行的**JavaServerFaces**（**JSF**组件套件。如果您了解 PrimeFaces，由于类似的 API，您将对 PrimeNG 感到宾至如归。目前，Priming 拥有 80 多个易于使用的视觉效果极佳的小部件。它们分为几个组，如输入和选择组件、按钮、数据迭代组件、面板、覆盖、菜单、图表、消息、多媒体、拖放和杂项。还有 22+个免费和高级主题。

PrimeNG 非常适合移动和桌面开发，因为它是一个响应迅速、触摸优化的框架。Priming showcase 是一个很好的地方，可以使用组件、在实际操作中试用组件、研究文档和代码片段。无论如何，我们需要一个系统的方法来开始启动启动。这就是这本书试图传达的内容。在本章中，我们将使用 SystemJS（[设置并运行 PrimeNGhttps://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs) ——支持多种模块格式的通用模块加载器。如果您想尝试使用 TypeScript、Angular、prime 代码片段，或者使用 Plunker（[编写小型应用程序，SystemJS 是一个很好的学习选择 https://plnkr.co](https://plnkr.co) ）因为它可以加载您的文件，传输它们（如果需要）并动态解决模块依赖关系。在实际应用程序中，您应该选择基于 Webpack 或 Angular CLI 的设置，这些设置具有更强大的功能和更高级的配置。它们还捆绑您的应用程序，以减少 HTTP 请求的数量。这些设置将在接下来的两部分中讨论。

<header>

# 角度传感器的 SystemJS 配置

</header>

首先，您需要安装 Node.js 和 npm，我们已经在*类型脚本基础知识*一节中提到了这一点。为什么我们需要 npm？在 HTML 和 SystemJS 配置中，我们可以引用[中的所有依赖项 https://unpkg.com](https://unpkg.com) 。但是，我们更喜欢在本地安装所有依赖项，这样 IDE 就可以自动完成。例如，要安装 SystemJS，必须在您选择的控制台中运行以下命令：

```ts
npm install systemjs --save

```

对于读者，我们创建了一个完整的演示种子项目，其中所有依赖项都列在`package.json`文件中。

The complete seed project with PrimeNG and SystemJS is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup).

种子项目中的所有依赖项都可以通过在项目根目录中运行`npm install`来安装。如果您浏览`index.html`文件，您可以看到 SystemJS 库包含在`<head>`标记中。之后，它成为一个全局`System`对象，公开了两个静态方法：`System.import()`和`System.config()`。第一种方法用于加载模块。它接受一个参数——模块名，可以是文件路径，也可以是映射到文件路径的逻辑名称。第二种方法用于设置配置。它接受配置对象作为参数。通常情况下，配置被放置在`systemjs.config.js`文件中。`index.html`中包含的完整脚本包括 TypeScript 编译器、Polyfills 和 SystemJS 相关文件。通过执行`System.import('app')`进行引导：

```ts
<script src="../node_modules/typescript/lib/typescript.js"></script>
<script src="../node_modules/core-js/client/shim.min.js"></script>
<script src="../node_modules/zone.js/dist/zone.js"></script>
<script src="../node_modules/systemjs/dist/system.src.js"></script>
<script src="../systemjs.config.js"></script>

<script>
  System.import('app').catch(function (err) {
    console.error(err);
  });
</script>

```

此处列出了角度项目配置对象的摘录：

```ts
System.config({
  transpiler: 'typescript',
  typescriptOptions: {
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "node",
    "sourceMap": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true
  },
  map: {
    '@angular/animations':
      'node_modules/@angular/animations/bundles/animations.umd.min.js',
    '@angular/common':
      'node_modules/@angular/common/bundles/common.umd.min.js',
    '@angular/compiler':
      'node_modules/@angular/compiler/bundles/compiler.umd.min.js',
    '@angular/core': 
      'node_modules/@angular/core/bundles/core.umd.min.js',
    '@angular/forms':
      'node_modules/@angular/forms/bundles/forms.umd.min.js',
    ...
    'rxjs': 'node_modules/rxjs',
    'app': 'src'
  },
  meta: {
    '@angular/*': {'format': 'cjs'}
  },
  packages: {
    'app': {
      main: 'main',
      defaultExtension: 'ts'
    },
    'rxjs': {main: 'Rx'}
});

```

简要说明概述了最重要的配置选项：

*   `transpiler`选项为 TypeScript 文件指定一个 transpiler。可能的值为`typescript`、`babel`和`traceur`。透明在浏览器中动态进行。
*   `typescriptOptions`选项设置 TypeScript 编译器选项。
*   `map`选项为模块名称创建别名。导入模块时，将根据映射将模块名称替换为关联值。在配置中，角度文件的所有入口点均为 UMD 格式。
*   `packages`选项设置导入模块的元信息。例如，您可以设置模块的主入口点。此外，您可以指定默认文件扩展名，以便在导入时能够忽略它们。

<header>

# 添加素数依赖项

</header>

使用 Priming 的每个项目都需要本地安装的库。您可以通过运行以下命令来实现这一点：

```ts
npm install primeng --save

```

因此，Priming 安装在`node_modules`文件夹下的项目根目录中，并作为依赖项添加到`package.json`中。在这里，如果您使用 GitHub 上托管的种子项目，您可以跳过这一步——只需运行`npm install`。下一步是向 SystemJS 配置文件添加两个新条目。对于较短的`import`语句，建议将`primeng`映射到`node_modules/primeng`。打底组件作为 CommonJS 模块分发，以`.js`结尾。这意味着我们也应该设置默认扩展名：

```ts
System.config({
  ...
  map: {
    ...
    'primeng': 'node_modules/primeng'
  },
  packages: {
    'primeng': {
      defaultExtension: 'js'
    },
    ...
  }
});

```

现在，您可以从`primeng/primeng`导入启动模块。例如，将此行写入导入`AccordionModule`和`MenuItem`：

```ts
import {AccordionModule, MenuItem} from 'primeng/primeng';

```

不建议在生产中使用这种导入方式，因为所有其他可用组件也将加载。相反，仅使用特定组件路径导入所需内容：

```ts
import {AccordionModule} from 'primeng/components/accordion/accordion';
import {MenuItem} from 'primeng/components/common/api';

```

在演示应用程序中，我们将只使用`ButtonModule`和`InputTextModule`，因此我们需要按如下方式导入它们：

```ts
import {ButtonModule} from 'primeng/components/button/button';
import {InputTextModule} from 'primeng/components/inputtext/inputtext';

```

我们要创建的演示项目由应用程序代码和资产组成。对每个文件的详细描述将超出本书的范围。我们将仅展示项目结构：

![](assets/4605bc24-7519-403c-a3fe-6c70f72f6293.png)

一个典型的启动应用程序需要一个主题。我们想以 B*ootstrap*为主题。文件`index.html`必须在`<head>`标记中包含三个 CSS 依赖项——主题、启动文件和 SVG 图标的文件（[http://fontawesome.io](http://fontawesome.io) ：

```ts
<link rel="stylesheet" type="text/css"
      href="../node_modules/primeng/resources/themes/bootstrap/theme.css"/>
<link rel="stylesheet" type="text/css"
      href="../node_modules/primeng/resources/primeng.min.css"/>
<link rel="stylesheet" type="text/css"
      href="src/assets/icons/css/font-awesome.min.css"/>

```

所有文件都放在`src/assets/icons`下。大多数启动组件是本机的，但是有一个具有第三方依赖关系的组件列表。下表对此进行了说明：

| **组件** | **依赖关系** |
| 日程 | FullCalendar 和 Moment.js |
| 编辑 | 羽毛笔编辑器 |
| GMap | 谷歌地图 |
| 图表 | Charts.js |
| 验证码 | 谷歌雷帕查 |

这些依赖关系的确切链接将在后面的具体示例中显示。现在，我们已经完成了设置。让我们在项目根目录中运行`npm start`来启动我们的第一个应用程序。

应用程序在浏览器中启动，带有两个启动组件，如下面的屏幕截图所示。如您所见，浏览器中加载了大量单一 web 资源（CSS 和 JS 文件）：

![](assets/bb6b4b11-9524-4017-8463-5c0a98ca5e1b.png)

<header>

# 使用网页包设置素描项目

</header>

网页包（[https://webpack.js.org](https://webpack.js.org) 是单页应用程序事实上的标准绑定器。它分析 JavaScript 模块、资产（样式、图标和图像）以及应用程序中其他文件之间的依赖关系，并将所有内容捆绑在一起。在 Webpack 中，所有内容都是一个模块。例如，您可以使用`require('./myfile.css')`或`import './myfile.css'`导入 CSS 文件，如 JavaScript 文件。

Webpack 可以通过文件扩展名和相关加载程序为导入的文件制定正确的处理策略。构建一个大的 bundle 文件并不总是合理的。Webpack 有各种插件可以分割代码并生成多个捆绑文件。它还可以按需异步加载部分应用程序（延迟加载）。所有这些特性使它成为一种动力工具。在本节中，我们将从较高的层次概述 Webpack2 的核心概念，并展示创建基于 Webpack 的角度、启动应用程序的基本步骤。

The complete seed project with PrimeNG and Webpack is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup).
The project structure was kept the same as in the SystemJS-based setup.

<header>

# 入口点和输出

</header>

JavaScript 和其他相互导入的文件紧密交织在一起。Webpack 创建所有此类依赖关系的图表。此图的起点称为*入口点*。入口点告诉 Webpack 从何处开始解析所有依赖项，并创建一个捆绑包。使用`entry`属性在网页包配置文件中创建入口点。在 GitHub 上的种子项目中，我们有两个配置文件，一个用于开发模式（`webpack.dev.js`），一个用于生产模式（`webpack.prod.js`），每个都有两个入口点。

在开发模式中，我们使用 JIT 编译的主入口点。`main.jit.ts`文件包含非常正常的引导代码。第二个入口点结合了来自`core-js`（用于现代 ECMAScript 功能的 Polyfills）和`zone.js`（Angular 的更改检测基础）的文件：

```ts
entry: {
  'main': './main.jit.ts',
  'polyfill': './polyfill.ts'
}

```

在生产模式中，我们使用 AOT 编译的主入口点。JIT 和 AOT 在*角度模块化和生命周期挂钩*一节中提到：

```ts
entry: {
  'main': './main.aot.ts',
  'polyfill': './polyfill.ts'
}

```

[T0]属性告诉 Webpack 将应用程序捆绑到哪里。您可以使用占位符，例如`[name]`和`[chunkhash]`来定义输出文件的名称。`[name]`占位符将替换为`entry`属性中定义的名称。在项目构建时，`[chunkhash]`占位符将被文件内容的哈希替换。`chunkFilename`选项确定按需（惰性）加载的块的名称——由`System.import()`加载的文件。在开发模式中，由于哈希生成过程中的性能问题，我们不使用`[chunkhash]`：

```ts
output: {
  filename: '[name].js',
  chunkFilename: '[name].js'
}

```

在生产模式中使用`[chunkhash]`占位符来实现所谓的*长期缓存*——每个文件都缓存在浏览器中，当哈希值发生变化时，会自动失效并重新加载：

```ts
output: {
  filename: '[name].[chunkhash].js',
  chunkFilename: '[name].[chunkhash].js'
}

```

A hash in the filename changes every compilation when the file content is changed. That means, files with hashes in names can not be included manually in the HTML file (`index.html`). `HtmlWebpackPlugin` ([https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)) helps us to include generated bundles with `<script>` or `<link>` tags in the HTML. The seed project makes use of this plugin.

<header>

# 加载程序和插件

</header>

Webpack 仅将 JavaScript 文件理解为模块。导入时，其他每个文件（`.css`、`.scss`、`.json`、`.jpg`等）都可以转换为模块。*加载程序*转换这些文件并将其添加到依赖关系图中。加载器配置应在`module.rules`下完成。加载程序配置中有两个主要选项：

*   带有正则表达式的[T0]属性，用于测试加载程序应应用于的文件
*   具有混凝土装载机名称的`loader`或`use`属性

```ts
module: {
  rules: [
    {test: /.json$/, loader: 'json-loader'},
    {test: /.html$/, loader: 'raw-loader'},
    ...
  ]
}

```

请注意，装载机应在`package.json`中注册，以便在`node_modules`下安装。Webpack 主页对一些流行的加载程序有很好的概述（[https://webpack.js.org/loaders](https://webpack.js.org/loaders) ）。对于 TypeScript 文件，建议在开发模式下使用以下加载程序序列：

```ts
{test: /.ts$/, loaders: ['awesome-typescript-loader', 'angular2-template-loader']}

```

从右到左应用多个装载机。`angular2-template-loader`搜索`templateUrl`和`styleUrls`声明，并在`@Component`装饰器中内联 HTML 和样式。`awesome-typescript-loader`主要是为了加快编译过程。对于 AOT 编译（生产模式），需要另一种配置：

```ts
{test: /.ts$/, loader: '@ngtools/webpack'}

```

Webpack 不仅有加载器，还有*插件*，它们负责加载器之外的自定义任务。自定义任务可以是压缩资产、将 CSS 提取到单独的文件中、生成源映射、定义编译时配置的常量，等等。种子项目中使用的一个有用的插件是`CommonsChunkPlugin`。它生成在入口点之间共享的公共模块块，并将它们拆分为单独的捆绑包。这将导致页面速度优化，因为浏览器可以从缓存中快速提供共享代码。在 seed 项目中，我们将 Webpack 的运行时代码移动到一个单独的`manifest`文件中，以支持长期缓存。这将避免在仅更改应用程序文件时重新创建供应商文件的哈希：

```ts
plugins: [
  new CommonsChunkPlugin({
    name: 'manifest',
    minChunks: Infinity
  }),
  ...
]

```

如您所见，插件的配置是在`plugins`选项中完成的。这里还有两个用于产品配置的插件需要提及。`AotPlugin`启用 AOT 编译。需要知道`tsconfig.json`的路径和用于引导的模块类路径：

```ts
new AotPlugin({
  tsConfigPath: './tsconfig.json',
  entryModule: path.resolve(__dirname, '..') + 
               '/src/app/app.module#AppModule'
})

```

`UglifyJsPlugin`用于代码缩小：

```ts
new UglifyJsPlugin({
  compress: {
    dead_code: true,
    unused: true,
    warnings: false,
    screw_ie8: true
  },
  ...
})

```

<header>

# 添加素描、CSS 和 SASS

</header>

是时候完成设置了。首先，确保在`package.json`文件中有 priming 和 FontAwesome 依赖项。例如：

```ts
"primeng": "~2.0.2",
"font-awesome": "~4.7.0"

```

其次，将所有 CSS 文件捆绑到一个文件中。此任务由`ExtractTextPlugin`完成，加载程序和插件配置需要此任务：

```ts
{test: /.css$/, loader: ExtractTextPlugin.extract({
    fallback: "style-loader",
    use: "css-loader"
  })
},
{test: /.scss/, loader: ExtractTextPlugin.extract({
    fallback: "style-loader",
    use: ['css-loader', 'sass-loader']
  }),
  exclude: /^_.*.scss/
}
...
plugins: [
  new ExtractTextPlugin({
    filename: "[name].css"  // file name of the bundle
  }),
  ...
]

```

For production, you should set the filename to `"[name].[chunkhash].css"`. The bundled CSS file gets automatically included into `index.html` by `HtmlWebpackPlugin`.

我们不希望在组件中使用`styleUrls`。种子项目在一个位置导入 CSS 和 SASS 文件——位于`src/assets/css`下的`main.scss`文件内：

```ts
// vendor files (imported from node_modules)
@import "~primeng/resources/themes/bootstrap/theme.css";
@import "~primeng/resources/primeng.min.css";
@import "~font-awesome/css/font-awesome.min.css";

// base project stuff (common settings)
@import "global";

// specific styles for components
@import "../../app/app.component";
@import "../../app/section/section.component";

```

请注意，波浪线`~`指向`node_modules`。更准确地说，Sass 预处理器将其解释为`node_modules`文件夹。Sass 在[第 2 章](02.html)、*主题概念和布局*中进行了解释。`main.scss`文件应在`main.jit.ts`和`main.aot.ts`入口点导入：

```ts
import './assets/css/main.scss';

```

Webpack 负责剩下的部分。Webpack 中有更多的好东西——一个实时重新加载的开发服务器`webpack-dev-server`（[https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server) ）。它检测对文件所做的更改并自动重新编译。您可以以`npm start`或`npm run start:prod`开头。这些命令表示 npm 脚本：

```ts
"start": webpack-dev-server --config config/webpack.dev.js --inline --open
"start:prod": webpack-dev-server --config config/webpack.prod.js --inline --open

```

When running `webpack-dev-server`, the compiled output is served from memory. This means, the application being served is not located on disk in the `dist` folder.

这就是全部。在[第 10 章](10.html)、*创建健壮应用*中将增加更多用于单元和端到端测试的配置选项。

<header>

# 使用 Angular CLI 设置打底项目

</header>

角度 CLI（[https://cli.angular.io](https://cli.angular.io) ）是一个现成的创建、运行和测试角度应用程序的舒适工具。它很快就能生成代码。我们将描述一些有用的命令，并向您展示如何将预处理与 Angular CLI 集成。首先，该工具应在全球范围内安装：

```ts
npm install -g @angular/cli

```

安装后，每一个命令都可以在控制台中通过预先设置的`ng`执行。例如，要创建新项目，请运行`ng new [projectname] [options]`。让我们创建一个。导航到将作为项目父目录的目录，并运行以下命令：

```ts
ng new primeng-angularcli-setup --style=scss

```

此命令将在文件夹`primeng-angularcli-setup`中创建一个 Angular 4 项目。选项`--style`设置 CSS 预处理器。在这里，我们想要使用 SASS 文件，并且需要一个 SASS 预处理器。每当我们进行更改时，预处理器都会编译 SASS 文件。如果只有 CSS 文件，则不需要设置预处理器。

The complete preconfigured seed project with PrimeNG and Angular CLI is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup).

创建的项目具有以下顶级目录和文件：

| **目录/文件** | **简短描述** |
| `e2e` | 包含 e2e 测试（`.e2e-spec.ts`文件）和页面对象（`.po.ts`文件）的文件夹。 |
| `src` | 应在其中写入应用程序代码的源代码文件夹。 |
| `.angular-cli.json` | 设置配置文件。这里可以列出预处理依赖项。 |
| `karma.conf.js` | 单元测试的 Karma 配置文件。 |
| `protractor.conf.js` | e2e 测试的量角器配置文件。 |
| `package.json` | 基于 npm 的项目包管理标准文件。 |
| `tsconfig.json` | TypeScript 编译器的设置。 |
| `tslint.json` | TSLint 的设置。 |

您现在可以通过键入以下命令启动应用程序：

```ts
ng serve

```

默认情况下，此命令将在`http://localhost:4200`运行本地服务器。你会看到文本应用程序工作！在浏览器中。`ng serve`命令在内部使用`webpack-dev-server`。服务器正在监视模式下运行。当发生任何更改时，它会自动刷新页面。有很多配置选项。例如，您可以通过`--port`选项设置自定义端口。有关更多详细信息，请参阅[中的官方文件 https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki) 。要将应用程序编译到输出目录，请运行以下命令：

```ts
ng build

```

构建工件将存储在`dist`目录中。

The `--prod` option in `ng build` or `ng serve` will minify the files and remove unused (dead) code. The `--aot` option will use AOT compilation and produce even more smaller and optimized artifacts.

要运行单元测试和 e2e 测试，请分别执行`ng test`和`ng e2e`命令。

<header>

# 生成脚手架

</header>

Angular CLI 允许我们使用`ng generate`生成组件、服务、指令、路由、管道等。以下是生成组件的方法：

```ts
ng generate component path/name

```

例如，如果我们运行以下命令：

```ts
ng generate component shared/message

```

将生成四个文件，并更新一个文件。生产的产量将是：

```ts
installing component
 create src/app/shared/message/message.component.scss
 create src/app/shared/message/message.component.html
 create src/app/shared/message/message.component.spec.ts
 create src/app/shared/message/message.component.ts
 update src/app/app.module.ts 

```

新组件自动注册到`app.module.ts`中。其他脚手架的生成是相同的。例如，要生成服务，请运行以下命令：

```ts
ng generate service path/name

```

有很多有用的选择。例如，您可以将[T0]设置为跳过测试文件生成。

<header>

# 添加素数依赖项

</header>

将预处理与 Angular CLI 集成非常简单。首先，安装并保存依赖项：

```ts
npm install primeng --save
npm install font-awesome --save

```

第二，编辑`.angular-cli.json`文件，并在`styles`部分添加三个 CSS 文件。这些文件与基于 SystemJS 和网页包的设置中的文件相同：

```ts
"styles": [
  "styles.css",
  "../node_modules/primeng/resources/themes/bootstrap/theme.css",
  "../node_modules/primeng/resources/primeng.min.css",
  "../node_modules/font-awesome/css/font-awesome.min.css"
]

```

现在，您可以导入所需的启动模块。请参阅*使用 SystemJS 运行预充*部分，了解如何导入预充模块。在 GitHub 的种子项目中，我们导入了`MessagesModule`并在`message.component.html`和`message.component.ts`中加入了一些演示代码。

![](assets/030e2299-dbdf-4a52-a096-d608b39d0077.png)

<header>

# 总结

</header>

在阅读本章之后，您将获得在接下来的章节中需要理解的 TypeScript 和 Angular 概念的概述。TypeScript 引入了有助于在开发时识别错误的类型。有基本类型、从面向对象编程语言中已知的类型、自定义类型等等。默认情况下，即使存在类型错误，TypeScript 编译器也始终发出 JavaScript 代码。通过这种方式，只需将`.js`文件重命名为`.ts`即可将任何现有 JavaScript 代码快速迁移到 TypeScript，而无需一次性修复所有编译错误。

典型的角度应用程序是用 TypeScript 编写的。Angular 提供了一种基于组件的方法，将 UI 逻辑与应用程序（业务）逻辑分离。它实现了一个强大的依赖注入系统，使得重用服务变得轻而易举。依赖注入还增加了代码的可测试性，因为您可以轻松地模拟业务逻辑。角度应用程序由层次化组件组成，它们以各种方式相互通信，如`@Input`、`@Output`属性、共享服务、局部变量等。

Angular 是一个模块化框架。用`@NgModule`注释的模块类提供了一种保持代码整洁和有序的好方法。Angular 是灵活的——生命周期挂钩允许我们在组件生命周期的几个阶段执行自定义逻辑。最后但并非最不重要的一点是，由于智能变化检测算法，它的速度很快。Angular 不提供任何丰富的 UI 组件。它只是一个开发单页应用程序的平台。您需要一个第三方库来创建丰富的 UI 界面。

Priming 是 Angular 2+的丰富 UI 组件的集合。与竞争对手相比，PrimeNG 是为企业应用程序创建的，提供了 80 多个组件。添加预处理依赖项很容易。您只需向`package.json`文件中添加 PrimeNG 和 FontAwesome 依赖项，并为您喜欢的任何主题添加三个 CSS 文件：`primeng.min.css`、`font-awesome.min.css`和`theme.css`。下一章将详细介绍主题化概念。

角度和打底应用程序由 ES6（ECMAScript 2015）模块组成。可以导出和导入模块。应用程序中的所有模块都构建依赖关系图。因此，您需要一个特定的工具来解析从某个入口点开始的模块，并输出一个包。有一些工具可以完成此任务和其他任务，如按需加载模块等。

在本章中，讨论了 SystemJS 和 Web 包加载程序。SystemJS 仅推荐用于演示应用程序，用于学习。基于网页包的构建更加复杂。Webpack 为每种文件类型和插件组合了加载程序。插件在 Webpack 构建过程中包含有用的行为，例如，创建公共块、缩小 web 资源、复制文件和目录、创建 SVG 精灵等等。要在 TypeScript 和 Angular 中快速启动开发，请使用 Angular CLI 生成项目。这是一个脚手架工具，可以轻松创建开箱即用的应用程序。