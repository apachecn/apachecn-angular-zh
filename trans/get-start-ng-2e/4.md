# 第 4 章。角度组件和指令入门

至此，我们已经熟悉 Angular 为单页应用程序开发提供的核心构建块以及它们之间的关系。然而，通过介绍 Angular 概念背后的一般思想以及用于定义这些概念的基本语法，我们只触及了表面。在本章中，我们将深入探讨 Angular 的组件和指令。

在以下各节中，我们将介绍这些主题：

*   强制分离用于开发应用程序的构建块的关注点。
*   与 DOM 交互时指令或组件的适当使用。
*   内置指令和开发自定义指令。
*   深入了解组件及其模板。
*   内容投影。
*   查看子项与内容子项。
*   组件的生命周期。
*   使用模板引用。
*   配置 Angular 的更改检测。

# Angular 中的“Hello world！”应用程序

现在，让我们在 Angular 中构建第一个“Hello world！”应用程序。为了让一切尽可能简单、快速地启动和运行，对于我们的第一个应用程序，我们将使用 ECMAScript 5 语法和 transpiled 包 Angular。首先，创建具有以下内容的`index.html`文件：

```ts
<!-- ch4/es5/hello-world/index.html --> 

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
</head>
<body>
  <script src="https://unpkg.com/zone.js@0.6.25/dist/zone.js"></script>
  <script src="https://unpkg.com/reflect-metadata@0.1.3/Reflect.js"></script>
  <script src="https://unpkg.com/rxjs@5.0.1/bundles/Rx.js"></script>
  <script src="https://unpkg.com/@angular/core@2.2.0/bundles/core.umd.js"></script>
  <script src="https://unpkg.com/@angular/common@2.2.0/bundles/common.umd.js"></script>
  <script src="https://unpkg.com/@angular/compiler@2.2.0/bundles/compiler.umd.js"></script>
  <script src="https://unpkg.com/@angular/platform-browser@2.2.0/bundles/platform-browser.umd.js"></script>
  <script src="https://unpkg.com/@angular/platform-browser-dynamic@2.2.0/bundles/platform-browser-dynamic.umd.js"></script>
  <script src="./app.js"></script>
</body>
</html>

```

### 注

请注意，本书中的示例是使用 Angular 2.2.0 构建的。如果您使用的是较新版本的框架，可能会有一些细微的差异。有关更多信息，请查看[上的变更日志 https://github.com/angular/angular/blob/master/CHANGELOG.md](https://github.com/angular/angular/blob/master/CHANGELOG.md) 。

前面的 HTML 文件定义了页面的基本结构。在关闭[T0]标记之前，我们引用了一些脚本文件：框架所需的 polyfills（zone.js 和 reflect metadata）、RxJS、Angular 的不同包的 ES5 包，以及包含我们将要构建的应用程序的文件。

### 注

Angular 的核心使用 RxJS，以允许我们在应用程序中支持反应式编程范式。在以下内容中，我们将仅对如何利用可见光进行一个粗略的介绍。有关更多信息，您可以访问位于[的 RxJS GitHub 存储库 https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs) 。

在您的`index.html`所在的同一目录中，创建一个名为`app.js`的文件，并在其中输入以下内容：

```ts
// ch4/es5/hello-world/app.js 

var App = ng.core.Component({
  selector: 'my-app',
  template: '<h1>Hello {{target}}!</h1>'
})
.Class({
  constructor: function () {
    this.target = 'world';
  }
});

var AppModule = ng.core.NgModule({
  imports: [ng.platformBrowser.BrowserModule],
  declarations: [App],
  bootstrap: [App]
})
.Class({
  constructor: function () {}
});

ng.platformBrowserDynamic
 .platformBrowserDynamic()
 .bootstrapModule(AppModule);

```

在前面的代码片段中，我们定义了一个名为`App`的组件，其中包含一个`my-app`选择器。该组件具有以下模板：

```ts
'<h1>Hello {{target}}!</h1>' 

```

从 AngularJS 开始，您应该已经熟悉了这种语法。当在给定组件的上下文中编译时，前面的代码段将在花括号内插入带有表达式结果的模板。在我们的例子中，表达式只是`target`变量。

向`Class`传递一个 object literal，它有一个名为`constructor`的方法。此**DSL**（**领域特定语言**）提供了一种在 ECMAScript 5 中定义类的替代方法。在`constructor`函数体中，我们添加了一个名为`target`的属性，其值为`"world"`字符串。紧接着，我们定义了`AppModule`类。请注意，应用程序上的每个组件都必须与一个模块相关联。在模块内部，如[第 2 章](2.html "Chapter 2. The Building Blocks of an Angular Application")*Angular Application*的构建块所述，我们定义了声明、导入和引导组件。

在代码片段的最后一行，我们调用了通过调用`ng.platformBrowserDynamic()`返回的对象的`bootstrapModule`方法。作为[T2]的参数，我们传递刚才定义的[T3]。

请注意，`bootstrapModule`位于`ng.platformBrowserDynamic`名称空间之下。这是因为构建框架时考虑了不同的平台，例如浏览器、NativeScript 等。通过将不同平台使用的引导方法放在单独的命名空间下，Angular 可以实现不同的逻辑来初始化应用程序。

现在，如果你用浏览器打开`index.html`，你会看到一些错误，如下图所示：

![The "Hello world!" application in Angular](graphics/B06166_04_01.jpg)

图 1

这是因为我们错过了一些非常重要的事情。我们没有在`index.html`中的任何地方使用根组件。为了完成应用程序，请在 body 元素的 open 标记后添加以下 HTML 元素：

```ts
<my-app></my-app> 

```

现在，您可以刷新浏览器以查看以下结果：

![The "Hello world!" application in Angular](graphics/2.jpg)

图 2

# 使用打字脚本

虽然我们已经有一个 Angular 应用程序在运行，但我们可以做得更好！我们没有使用任何包管理器或模块加载器。我们花了[第三章](3.html "Chapter 3. TypeScript Crash Course")、*打字速成班*的全部时间讨论打字；但是，在前面的应用程序中，我们没有编写一行。虽然不需要将 TypeScript 与 Angular 一起使用，但是利用静态类型提供的所有好处更方便。通过使用 TypeScript，我们还可以在 Angular 中使用提前编译。

## 建立我们的环境

Angular 的核心团队为 Angular 开发了一个全新的 CLI 工具，它允许我们用几个命令引导应用程序。虽然我们将在最后一章中介绍它，但为了提高我们的学习体验，我们将使用位于[的代码 https://github.com/mgechev/getting-started-with-angular](https://github.com/mgechev/getting-started-with-angular) 。该存储库包含本书中的所有示例，它们位于一个大型应用程序中。它具有`package.json`中声明的所有必需的依赖项，基本 gulp 任务的定义，如开发服务器、将 TypeScript 代码转换为 ECMAScript 5、实时重新加载等。

### 注

包含本书所有示例的项目基于 angular seed（[https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed) ），它允许我们快速引导角度应用程序。

为了设置`getting-started-with-angular`项目，您需要在计算机上安装并运行 Git、Node.js v6.x.x 和 npm。如果您安装了不同版本的 Node.js，我建议您查看 nvm（Node.js 版本管理器，可在[上找到）https://github.com/creationix/nvm](https://github.com/creationix/nvm) 或 n（[https://www.npmjs.com/package/n](https://www.npmjs.com/package/n) ）。使用这些工具，您可以在计算机上拥有多个版本的 Node.js，并通过命令行通过单个命令在它们之间切换。

## 安装样本项目库

让我们从建立`getting-started-with-angular`项目开始。打开终端并输入以下命令：

```ts
# Will clone the repository and save it to directory called
# getting-started-with-angular
$ git clone https://github.com/mgechev/getting-started-with-angular.git
$ cd getting-started-with-angular
$ npm install

```

第一行将`getting-started-with-angular`项目克隆到名为`getting-started-with-angular`的目录中；然后我们进入那个目录。

在能够运行 seed 项目之前的最后一步是使用 npm 安装所有必需的依赖项。此步骤可能需要一段时间，具体取决于您的 Internet 连接，因此请耐心等待，不要中断。如果您遇到任何问题，请毫不犹豫地在[处提出问题 https://github.com/mgechev/getting-started-with-angular/issues](https://github.com/mgechev/getting-started-with-angular/issues) 。

剩下的最后一步是启动开发服务器：

```ts
$ npm start 

```

当传输过程完成时，您的浏览器将自动打开并显示`http://localhost:5555/dist/dev`。现在，您将看到一个类似于以下屏幕截图所示的视图：

![Installing the sample project repository](graphics/3.jpg)

图 3

# 玩棱角和字体

现在，让我们来看看我们已经有的文件。导航到`getting-started-with-angular`中的`app/ch4/ts/hello-world`目录。然后，打开`app.ts`并用以下代码片段替换其内容：

```ts
// ch4/ts/hello-world/app.ts 

import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'my-app',
  templateUrl: './app.html'
})
class App {
  target: string;
  constructor() {
    this.target = 'world';
  }
}

@NgModule({
  declarations: [App],
  imports: [BrowserModule],
  bootstrap: [App],
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);

```

让我们逐行查看代码：

```ts
import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';
```

最初，我们从`@angular/core`模块导入`@Component`和`@NgModule`装饰器，从`@angular/platform-browser`导入`BrowserModule`，从`@angular/platform-browser-dynamic`导入`platformBrowserDynamic`对象。后来我们用`@Component`来装饰`App`课。我们向`@Component`装饰程序传递了应用程序 ECMAScript 5 版本中使用的相同对象文本，但这次我们引用了一个外部模板。

作为下一步，我们定义组件的视图。但是，请注意，在本例中，我们使用`templateUrl`而不是简单地内联组件的模板。

打开`app.html`并将文件内容替换为`<h1>Hello {{target}}!</h1>`。`app.html`的内容应该与我们之前使用的内联模板相同。由于我们可以通过内联模板（使用[T3]）和设置其 URL（[T4]）来使用模板，因此在某种意义上，组件的 API 类似于 AngularJS 指令 API。

在代码段的最后一行，我们通过提供根模块来引导应用程序。

现在，让我们看看 Apple T0T，以便了解当我们启动应用程序时会发生什么：

```ts
<!-- ch4/ts/hello-world/index.html --> 
<!DOCTYPE html> 
<html lang="en"> 
<head> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
  <title><%= TITLE %></title> 
  <meta name="description" content=""> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <!-- inject:css --> 
  <!-- endinject --> 
</head> 
<body> 
  <my-app>Loading...</my-app> 
  <!-- inject:js --> 
  <!-- endinject --> 
  <%= INIT %> 
</body> 
</html> 

```

请注意，在页面主体内部，我们使用了[T0]元素，其内容是一个值为[T1]的文本节点。`"Loading..."`标签将一直可见，直到应用程序启动并呈现主组件。

### 注

有模板占位符`<%= INIT %>` 和`<-- inject:js...`注入特定于单个演示的内容。它们不是特定于角度的，而是旨在防止由于它们之间的共享结构而导致附在书中的代码示例中的代码重复。要查看此特定 HTML 文件是如何转换的，请打开`/dist/dev/ch4/ts/hello-world/index.html`。

# 使用角度指令

我们已经构建了简单的“Hello world！”应用程序。现在，让我们开始构建更接近实际应用程序的东西。在本节结束时，我们将有一个简单的应用程序，它列出了我们需要做的许多事情，并在页面的页眉处向我们致意。

让我们从开发`app`组件开始。我们需要对前面示例进行的两个修改是将`target`属性重命名为`name`，并将`todos`列表添加到组件的控制器定义中：

```ts
// ch4/ts/ng-for/detailed-syntax/app.ts 

import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'app',
  templateUrl: './app.html',
})
class App {
  todos: string[];
  name: string;
  constructor() {
    this.name = 'John';
    this.todos = ['Buy milk', 'Save the world'];
  }
}

@NgModule({
  declarations: [App],
  imports: [BrowserModule],
  bootstrap: [App],
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);

```

剩下的唯一一件事就是更新模板以使用提供的数据。我们已经熟悉 AngularJS 的`ng-repeat`指令。它允许我们使用 microsyntax 循环查看项目列表，稍后由 AngularJS 进行解释。然而，该指令没有足够的语义，因此很难构建执行静态代码分析并帮助我们改进开发经验的工具。由于`ng-repeat`指令非常有用，Angular 保留了这个想法并进一步改进了它，以便通过在上面引入进一步的语义来允许更复杂的工具。它允许 IDE 和文本编辑器执行更好的静态代码分析。这样的支持将防止我们在编写的代码中出现拼写错误，并使我们拥有更流畅的开发体验。

在`app.html`中增加以下内容：

```ts
<!-- ch4/ts/ng-for/detailed-syntax/app.html --> 

<h1>Hello {{name}}!</h1> 
<p> 
  Here's a list of the things you need to do: 
</p> 
<ul> 
  <template ngFor let-todo [ngForOf]="todos"> 
    <li>{{todo}}</li> 
  </template> 
</ul> 

```

### 注

`template`元素是一个我们可以保存标记并确保它不会被浏览器呈现的地方。如果我们需要将应用程序的模板直接嵌入到页面的标记中，并让我们使用的模板引擎在某个时候处理它们，那么这是非常有用的。在当前示例中，这意味着如果 Angular 的 DOM 编译器不处理 DOM 树，我们将不会在`ul`元素中看到列表项。

现在，刷新浏览器后，您应该会看到以下结果：

![Using Angular directives](graphics/4-2.jpg)

图 4

到目前为止，一切都很好！在前面的代码片段中只剩下我们不熟悉的`template`元素的属性，如`ngFor`、`let-todo`和`[ngForOf]`。让我们看看它们。

## ngFor 指令

`ngFor`指令是一个指令，它允许我们在一组项目上循环，并且与`ng-repeat`在 AngularJS 中的作用完全相同，但它带来了一些额外的语义。注意，`ngForOf`属性被括号包围。起初，这些括号看起来像是无效的 HTML。但是，根据 HTML 规范，允许在属性名称中使用它们。W3C 验证器唯一会抱怨的是`template`元素不拥有这样的属性；但是，浏览器在处理标记时不会有问题。

这些括号背后的语义是，它们所包围的属性的值是一个表达式，需要对其进行计算。

# 改进了指令语法的语义

在[第 1 章](1.html "Chapter 1. Get Going with Angular")*开始使用 Angular*中，我们提到了改进 Angular 模具的机会。AngularJS 中的一个大问题是我们可以使用指令的不同方式。这需要了解属性值，属性值可以是文字、表达式、回调或微语法。从 Angular 2 开始，通过引入框架中内置的一些简单约定，可以消除此问题：

*   `propertyName="value"`
*   `[propertyName]="expression"`
*   `(eventName)="handler()"`

在第一行中，`propertyName`属性接受字符串文字作为值。Angular 不会进一步处理属性的值；它将按照在模板中设置的方式使用它。

第二种语法`[propertyName]="expression"`提示 Angular，属性的值应该作为表达式处理。当 Angular 找到一个被方括号包围的属性时，它将在与模板关联的组件上下文中解释表达式。简而言之，如果我们想将一个非字符串值或表达式的结果设置为给定属性的值，我们需要使用这种语法。

最后一个示例显示了如何绑定到事件。`(eventName)="handler()"`背后的语义是，我们希望处理所有被称为`eventName`的事件，这些事件由具有`handler()`表达式的给定组件触发。

我们将在本章后面讨论更多示例。

### 注

Angular 提供了另一种规范语法，它允许我们在不使用括号的情况下定义元素的绑定。例如，属性绑定可以使用以下代码表示：`<input [value]="foo">`

也可以用以下方式表示：`<input bind-value="foo">`

类似地，我们可以用以下代码表示事件绑定：`<button (click)="handle()">Click me</button>`

它们也可以用以下方式表示：`<button on-click="handle()">Click me</button>`

## 在模板内声明变量

前面模板剩下的最后一件事是`let-todo`属性。使用这种语法，我们告诉 Angular，我们想要声明一个名为`todo`的新变量，并将它绑定到集合中的各个项，我们从表达式集的求值中获得`[ngForOf]`值。

## 在模板中使用语法糖

尽管模板语法为我们使用的 IDE 或文本编辑器提供了更多的代码含义，但它相当冗长。Angular 提供了另一种语法，该语法将与前面代码段中所示的语法不同。

有一些角度指令需要使用模板元素，例如，`ngForOf`、`ngIf`和`ngSwitch`。由于经常使用此类指令，因此有一种替代语法。我们不必显式地输入整个模板元素，只需在指令前面加上前缀`*`。这将允许我们将`ngForOf`指令语法用法转换为以下内容：

```ts
<!-- ch4/ts/ng-for/syntax-sugar/app.html --> 

<ul> 
  <li *ngFor="let todo of todos">{{todo}}</li> 
</ul> 

```

稍后，该模板将按照前面描述的更详细的语法进行解析。由于不太详细的语法更易于读写，因此它的使用被认为是最佳实践。

### 注

`*`字符允许我们删除`template`元素，并将指令直接放在`template`的顶级子元素上（在上例中，列表项`li`。

# 定义角度指令

现在我们已经构建了一个简单的角度组件，让我们通过理解角度指令继续我们的旅程。

使用角度指令，我们可以在 DOM 上应用不同的行为或结构更改。在本例中，我们将构建一个简单的工具提示指令。

与组件不同，指令没有视图和模板。这两个概念之间的另一个核心区别是，给定的 HTML 元素可能只有一个组件，但有多个指令。换句话说，与视图中的实际元素相比，指令增加了元素。

Angular 的官方样式指南建议使用指令作为属性，前缀为名称空间。记住这一点，我们将按以下方式使用 tooltip 指令：

```ts
<div saTooltip="Hello world!"></div> 

```

在前面的代码片段中，我们在[T0]元素上使用了 tooltip 指令。作为名称空间，其选择器使用`sa`字符串。

### 注

由于本书的重点是对 Angular 的概念进行高效直观的学习，因此代码片段可能与 Angular 样式指南不完全一致。但是，对于生产应用程序，以下最佳实践是必不可少的。你可以在[找到官方的角度风格指南 https://angular.io/styleguide](https://angular.io/styleguide) 。

现在，让我们开发一个工具提示指令！在实现它之前，我们需要从`@angular/core`导入几个符号。打开一个名为`app.ts`的新类型脚本文件，输入以下内容；我们稍后将填充占位符：

```ts
import {Directive, ElementRef, HostListener...} from '@angular/core'; 

```

在前一行中，我们导入以下定义：

*   `ElementRef`：这允许我们将元素引用（我们不限于 DOM）注入宿主元素。在前面工具提示的示例用法中，我们得到了`div`元素的一个有角度的包装，它包含`saTooltip`属性。
*   `Directive`：此装饰器允许我们添加我们定义的新指令所需的元数据。
*   `HostListener(eventname)`：这是一个接受事件名称作为参数的方法修饰符。在指令初始化期间，Angular 将添加修饰方法作为宿主元素触发的`eventname`事件的事件处理程序。

让我们看看该指令的实现：

```ts
// ch4/ts/tooltip/app.ts 

@Directive({
  selector: '[saTooltip]'
})
export class Tooltip {
  @Input() saTooltip:string;

  constructor(private el: ElementRef, private overlay: Overlay) {
    this.overlay.attach(el.nativeElement);
  }

  @HostListener('mouseenter')
  onMouseEnter() {
    this.overlay.open(this.el, this.saTooltip);
  }

  @HostListener('mouseleave')
  onMouseLeave() {
    this.overlay.close();
  }
}

```

## 设置指令的输入

在前面的示例中，我们使用[T0]选择器声明了一个指令。注意 Angular 的 HTML 编译器区分大小写，这意味着它将区分[T1]和[T2]选择器。之后，我们使用`@Input`修饰符在`saTooltip`属性上声明指令的输入。这段代码背后的语义是，我们声明了一个名为`saTooltip`的属性，并将其绑定到从传递给`saTooltip`属性的表达式的求值中得到的结果值。

[T0]装饰器接受一个参数，即我们要绑定到的属性的名称。如果不传递参数，Angular 将在与属性本身同名的属性之间创建绑定。我们将在本章后面详细解释输入和输出的概念。

## 了解指令的构造函数

构造函数声明了两个私有属性：`ElementRef`类型的`el`和`Overlay`类型的`overlay`。`Overlay`类实现了管理工具提示覆盖的逻辑，并将使用 Angular 的 DI 机制进行注入。为了将其声明为可供注入，我们需要以以下方式声明顶级组件：

```ts
@Component({ 
  selector: 'app', 
  templateUrl: './app.html', 
  providers: [Overlay], 
  // ... 
}) 
class App {} 

```

### 注

在下一章中，我们将研究 Angular 的依赖注入机制，其中我们将解释如何声明服务、指令和组件的依赖关系。在本章中，`Overlay`类的实现并不重要。但是，如果您对它感兴趣，您可以在`ch4/ts/tooltip/app.ts`找到实现。

## 使用 NGM 模块更好地封装指令

为了使 tooltip 指令对 Angular 的编译器可用，我们需要显式声明我们打算在哪里使用它。例如，看看`ch4/ts/tooltip/app.ts`的`AppModule`类：

```ts
@NgModule({
  declarations: [Tooltip, App],
  providers: [Overlay],
  imports: [BrowserModule],
  bootstrap: [App],
})
class AppModule {}

```

向`@NgModule`装饰器传递一个具有`declarations`属性的对象文字。此属性包含所有组件子树中可用的所有指令的列表，其根为`bootstrap`数组中列出的任何组件。扩展可用指令列表的另一种方法是导入模块。例如，模块`BrowserModule`包含一些非常常用的浏览器环境指令。

首先，您应该显式声明模块中使用的所有指令，这可能看起来很烦人；然而，这强制了更好的封装。在 AngularJS 中，所有指令都位于全局命名空间中。这意味着应用程序中定义的所有指令都可以在所有模板中访问。这会带来一些问题，例如名称冲突。为了解决这个问题，我们引入了命名约定，例如，AngularJS 定义的所有指令的`"ng-"`前缀和 AngularUI 附带的所有指令的`"ui-"`。

目前，通过显式声明给定模块中使用的所有指令，我们创建了一个特定于各个组件子树的命名空间（也就是说，这些指令将对给定根组件及其所有后续组件可见）。防止名称冲突不是我们得到的唯一好处；它还可以帮助我们更好地理解我们生成的代码的语义，因为当我们知道它在哪个模块中声明时，我们总是知道给定组件可以访问的指令。我们可以通过遵循从组件到顶层模块的路径，并取[T0]的所有值和模块的[T1]声明的并集，找到给定组件的所有可访问指令。鉴于组件是从指令扩展而来的，我们还需要显式声明所有使用的组件。

由于 Angular 定义了一组内置指令，`BrowserModule`通过导出包含它们的模块`CommonModule`来导出它们。此预定义指令列表包括`NgClass`、`NgFor`、`NgIf`、`NgStyle`、`NgSwitch`、`NgSwitchWhen`和`NgSwitchDefault`。他们的名字不言自明；我们将在本章后面介绍如何使用其中的一些。

## 使用 NgModules 声明可重用组件

使用 NgModules，我们可以实现良好的封装程度。通过显式导出公共组件、指令、管道和服务，我们可以隐藏模块的一些实现细节。通过这种方式，我们可以实现可重用的模块，并且只公开它们的公共接口，并且我们不会向模块的用户公开任何低级组件。

为了得到更好的想法，我们来看看下面的例子：

```ts
@Component(...)
class ZippyHeader {
  @Input() header: string;
}

@Component(...)
class Zippy {
  @Input() header: string;
  visible = true;
}

@Component(...)
class App {}
```

在前面的代码片段中，我们声明了组件`Zippy`、`ZippyHeader`和`App`。`Zippy`是具有标题和内容的组件；我们可以通过点击标题来切换内容的可见性。在组件`ZippyHeader`中，我们可以实现一些逻辑来处理点击事件和/或可视化标题。在`App`组件中，我们通过传递标题和内容的文本来使用`Zippy`组件。

为了创建一个正常工作的 Angle 应用程序，我们需要声明一个 NgModule，它以某种方式引用了所有三个组件。我们可以通过两种主要方式实现这一点：

1.  声明单个 NgModule，并在其声明列表中包含所有三个组件。
2.  Declare two NgModules:
    *   声明`Zippy`和`ZippyHeader`组件的组件，称为`ZippyModule`。
    *   另一个声明`App`组件并导入模块`ZippyModule`的组件。

第二种方法有两个优点：在`ZippyModule`中，我们可以同时声明`Zippy`和`ZippyHeader`，但我们只能导出`Zippy`，因为`ZippyHeader`是在`Zippy`内部使用的，我们不必向用户公开。通过声明模块`ZippyModule`，我们可以将其导入到我们应用程序中的其他模块中，我们希望重用`Zippy`组件，或者我们甚至可以将其提取为单独的 npm 模块，并在多个应用程序中重用。

第二种方法如下所示：

```ts
// ch4/ts/zippy/app.ts

@Component(...)
class ZippyHeader {...}

@Component(...)
class Zippy {...}

@NgModule({
 declarations: [Zippy, ZippyHeader],
  exports: [Zippy]
  imports: [CommonModule],
})
class ZippyModule {}

@Component(...)
class App {...}

@NgModule({
  imports: [BrowserModule, ZippyModule],
  declarations: [App],
  bootstrap: [App]
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);
```

在上例中，在模块`ZippyModule`中，我们同时声明了`Zippy`和`ZippyHeader`，但我们只导出`Zippy`。我们还从`@angular/common`导入模块`CommonModule`，以便重用 Angular 的内置指令（例如，`NgIf`由`CommonModule`导出）。

在`AppModule`中，我们需要做的就是导入`ZippyModule`，这样我们就可以使用它的所有导出和提供者。我们将在下一章进一步讨论提供者。

### 注

注意，良好的实践建议我们应该将每个单独的组件实现到一个单独的文件中。为了本书示例的简单性，我们违反了这一做法。有关最佳做法的列表，请访问[https://angular.io/styleguide](https://angular.io/styleguide) 。

## 使用自定义元素模式

现在，假设我们想在页面中添加一个计时器，并重用我们已经构建的 Web 组件。在这种情况下，我们的应用程序可以如下所示：

```ts
//  ch4/ts/custom-element/app.ts

import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'my-app',
  template: `
    <h1>Hello {{name}}</h1>
    The current timeout is <simple-timer></simple-timer>
  `
})
class App {
  name: string = 'John Doe';
}

@NgModule({
  imports: [BrowserModule],
  declarations: [App],
  bootstrap: [App]
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);
```

现在，如果我们运行应用程序，将出现以下错误：

![Using custom element schema](graphics/B06166_04_05.jpg)

图 5

Angular 解析`App`组件的模板时，会找到`<simple-timer></simple-timer>`。它不是 HTML 规范定义的元素，并且与[T2]中声明或导入的指令的任何选择器都不匹配，因此框架将抛出错误。

那么，我们如何使用自定义组件的角度？解决方案是使用传递给`@NgModule`的对象文本的`schemas`属性：

```ts
import {..., CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';

//...

@NgModule({
  imports: [BrowserModule],
  declarations: [App],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  bootstrap: [App]
})
class AppModule {}
```

通过这种方式，我们可以更改 Angular 在解析期间用于验证元素及其属性的默认模式。

默认情况下，如果框架发现与任何导入或声明指令的元素选择器或 HTML5 规范定义的元素不匹配的元素，则框架将抛出错误。

# 创建自定义角度组件

现在，让我们构建一个简单的 to-do 应用程序，以演示进一步定义组件的语法。

我们的待办事项将采用以下格式：

```ts
interface Todo { 
  completed: boolean; 
  label: string; 
} 

```

让我们从导入我们需要的所有内容开始：

```ts
import {Component, NgModule, ViewEncapsulation} from '@angular/core'; 
//...

```

现在，让我们声明组件及其关联的元数据：

```ts
@Component({ 
  selector: 'todo-app', 
  templateUrl: './app.html', 
  styles: [ 
    `ul li { 
      list-style: none; 
    } 
    .completed { 
      text-decoration: line-through; 
    }` 
  ], 
  encapsulation: ViewEncapsulation.Emulated 
}) 

```

这里，我们指定`Todo`组件的选择器为`todo-app`元素。稍后，我们添加模板 URL，它指向`app.html`文件。之后，我们使用`styles`属性；这是我们第一次遇到它。正如我们可以从其名称猜到的，它用于设置组件的样式。

## 引入组件的视图封装

正如我们所知，Angular 的灵感来自 Web 组件，其核心功能是 ShadowDOM。shadowdom 允许我们封装 Web 组件的样式，而不允许它们泄漏到组件的范围之外；Angular 提供了此功能。如果我们希望 Angular 的渲染器使用阴影 DOM，我们可以使用[T0]。然而，在撰写本书时，并非所有浏览器都支持影子 DOM；如果我们想在不使用影子 DOM 的情况下实现相同级别的封装，我们可以使用`ViewEncapsulation.Emulated`。

如果我们不想有任何封装，我们可以使用`ViewEncapsulation.None`。默认情况下，渲染器使用类型为`Emulated`的封装。

## 实现组件的控制器

现在，让我们继续执行应用程序：

```ts
// ch4/ts/todo-app/app.ts 
class TodoCtrl { 
  todos: Todo[] = [{ 
    label: 'Buy milk', 
    completed: false 
  }, { 
    label: 'Save the world', 
    completed: false 
  }];
  name: string = 'John'; 

  addTodo(label) { ... }

  removeTodo(idx) { ... } 

  toggleCompletion(idx) { ... } 
} 

```

以下是与`Todo`应用程序模板关联的控制器实现的一部分。在类声明中，我们将`todos`属性初始化为一个包含两个`todo`项的数组。

现在，让我们更新模板并呈现这些项目。这是如何做到的：

```ts
<ul> 
  <li *ngFor="let todo of todos; let index = index" [class.completed]="todo.completed"> 
    <input type="checkbox" [checked]="todo.completed" 
      (change)="toggleCompletion(index)"> 
    {{todo.label}} 
  </li> 
</ul> 

```

在前面的模板中，我们迭代了控制器的`todos`属性中的所有`todo`项。对于每个`todo`项，我们创建一个复选框，可以`toggle`该项的完成状态；我们还使用插值指令呈现`todo`项的标签。在这里，我们可以注意到前面解释过的语法：

*   我们使用`(change)="statement"`绑定复选框的更改事件。
*   我们使用`[checked]="expr"`绑定`todo`项的属性。

为了在已完成的`todo`项之间有一行，我们绑定到元素的`class.completed`属性。因为我们想将`completed`类应用于所有已完成的待办事项，所以我们使用`[class.completed]="todo.completed"`。这样，我们声明希望根据`todo.completed`表达式的值应用`completed`类。下面是我们的应用程序现在的外观：

![Implementing the component's controllers](graphics/6-5.jpg)

图 6

### 注

与类绑定语法类似，Angular 允许我们绑定到元素的样式和属性。例如，我们可以使用以下代码行绑定到`td`元素的`colspan`属性：`<td [attr.colspan]="colspanCount"></td> `

同样，我们可以使用以下代码行绑定到任何`style`属性：`<div [style.backgroundImage]="expression"></td>`

## 处理用户操作

到目前为止，一切都很好！现在，让我们实现`toggleCompletion`方法。此方法接受待办事项的索引作为参数：

```ts
toggleCompletion(idx) { 
  let todo = this.todos[idx]; 
  todo.completed = !todo.completed; 
} 

```

在`toggleCompletion`中，我们只需切换与当前待办事项相关联的`completed`布尔值，该值由作为参数传递给方法的索引指定。

现在，让我们添加一个文本输入来添加新的待办事项：

```ts
<p> 
  Add a new todo: 
  <input #newtodo type="text"> 
  <button (click)="addTodo(newtodo.value); newtodo.value = ''"> 
    Add 
  </button> 
</p> 

```

这里的输入定义了一个名为`newtodo`的新变量。现在，我们可以使用模板中的`newtodo`标识符引用输入元素。一旦用户点击按钮，控制器中定义的`addTodo`方法将被调用，其中`newtodo`输入值作为参数。在传递给`(click)`属性的语句中，我们还通过将`newtodo`输入设置为空字符串来重置其值。

### 注

请注意，直接操作 DOM 元素不被认为是最佳实践，因为它会阻止我们的组件在浏览器环境之外正常运行。我们将在[第 8 章](8.html "Chapter 8. Tooling and Development Experience")、*工具和开发经验*中解释如何将此应用程序迁移到 Web 工作者。

现在，让我们定义`addTodo`方法：

```ts
addTodo(label) { 
  this.todos.push({ 
    label, 
    completed: false 
  }); 
} 

```

在它里面，我们使用对象文本语法创建一个新的待办事项。

我们的应用程序只剩下实现删除现有待办事项。由于它与用于切换待办事项完成情况的功能非常相似，因此我将把它的实现留给读者作为一个简单的练习。

## 使用输入和输出

通过重构`todo`应用程序，我们将演示如何利用指令的输入和输出：

![Using inputs and outputs](graphics/B06166_04_07.jpg)

图 7

我们可以将输入视为给定指令接受的属性（甚至参数）。可以将输出视为它触发的事件。当我们使用第三方库提供的指令时，我们主要关心它的输入和输出，因为它们定义了它的 API。

输入是指参数化指令行为和/或视图的值。另一方面，输出指的是指令在发生特殊情况时触发的事件。

## 输入和输出的确定

现在，让我们将单片待办应用程序划分为相互通信的独立组件。在以下屏幕截图中，您可以看到各个组件，它们组合在一起时实现了应用程序的功能：

![Determining of the inputs and outputs](graphics/8-1.jpg)

图 8

外矩形代表整个`Todo`应用程序。第一个嵌套矩形包含负责输入新待办事项标签的组件，下面的矩形列出了存储在根组件中的各个项目。

话虽如此，我们可以将这三个组成部分定义如下：

*   `TodoApp`：负责维护待办事项列表（新增项目、切换完成状态）。
*   `InputBox`: This is responsible for entering the label of the new to-do item. It has the following inputs and outputs:
    *   输入：文本框的占位符和提交按钮的标签。
    *   输出：单击提交按钮后文本框的内容。
*   `TodoList`: This is responsible for rendering the individual to-do items. It has the following inputs and outputs:
    *   输入：待办事项列表。
    *   输出：待办事项的完成状态。

现在，让我们从实现开始！

## 定义输入和输出

让我们使用自下而上的方法，从`InputBox`组件开始。在此之前，我们需要从 Angular 的`@angular/core`包中进口两种产品：

```ts
import { 
  Component, 
  Input, 
  Output, 
  EventEmitter 
} from '@angular/core'; 

```

在前面的代码中，我们导入了`@Component`、`@Input`和`@Output`装饰器以及`EventEmitter`类。正如它们的名称所述，`@Input`和`@Output`用于声明指令的输入和输出。`EventEmitter`是一个泛型类（即接受一个类型参数），当与`@Output`装饰器结合使用时，可以帮助我们发出输出。

作为下一个步骤，让我们来看看 PosiT0}组件的声明：

```ts
// ch4/ts/inputs-outputs/app.ts 

@Component({ 
  selector: 'text-input', 
  template: ` 
    <input #todoInput [placeholder]="inputPlaceholder"> 
    <button (click)="emitText(todoInput.value); 
                     todoInput.value = '';"> 
      {{buttonLabel}} 
    </button> 
  ` 
}) 
class InputBox {...} 

```

请注意，在模板中，我们声明了一个文本输入，并使用`todoInput`标识符保留对它的引用，并将其占位符属性设置为我们从`inputPlaceholder`表达式的求值中获得的值。表达式的值是组件控制器中定义的`inputPlaceholder`属性的值。这是我们需要声明的第一个输入：

```ts
class InputBox { 
  @Input() inputPlaceholder: string; 
  ... 
} 

```

同样，我们声明`buttonLabel`组件的另一个输入，我们将其用作按钮标签的值：

```ts
class InputBox { 
  @Input() inputPlaceholder: string; 
  @Input() buttonLabel: string; 
  ... 
} 

```

在前面的模板中，我们将按钮的点击事件绑定到此`emitText(todoInput.value); todoInput.value = '';`语句。`emitText`方法应在组件控制器中定义；一旦被调用，它应该发出文本输入的值。以下是我们如何实现此行为：

```ts
class InputBox { 
  ... 
  @Output() inputText = new EventEmitter<string>();

  emitText(text: string) { 
    this.inputText.emit(text); 
  } 
} 

```

最初，我们声明一个名为`inputText`的输出。作为其值，我们设置了一个我们创建的`EventEmitter<string>`类型的新实例。

### 注

注意，所有组件的所有输出都需要是`EventEmitter`的实例。

在`emitText`方法中，我们调用`inputText`的`emit`方法，并将文本输入的值作为其参数传递。

现在，让我们以同样的方式定义`TodoList`组件：

```ts
@Component(...) 
class TodoList { 
  @Input() todos: Todo[]; 
  @Output() toggle = new EventEmitter<Todo>();

  toggleCompletion(index: number) { 
    let todo = this.todos[index]; 
    this.toggle.emit(todo); 
  } 
} 

```

因为传递给`@Component`装饰器的对象文本的值对于本节来说不是必需的，所以我们省略了它。此示例的完整实现可在`ch4/ts/inputs-outputs/app.ts`中找到。让我们来看看 AutoT2p 类的身体。类似地，对于`InputBox`组件，我们定义`todos`输入。我们还通过声明`toggle`属性来定义`toggle`输出，将其值设置为`EventEmitter<Todo>`类型的新实例，并使用`@Output`decorator 对其进行修饰。

## 传递输入并消耗输出

现在，让我们结合上一节中定义的组件，实现完整的应用程序。

我们需要查看的最后一个组件是`TodoApp`：

```ts
@Component({ 
  selector: 'todo-app',
  template: ` 
    <h1>Hello {{name}}!</h1> 

    <p> 
      Add a new todo: 
      <input-box inputPlaceholder="New todo..." 
        buttonLabel="Add" 
        (inputText)="addTodo($event)"> 
      </input-box> 
    </p> 

    <p>Here's the list of pending todo items:</p> 
    <todo-list [todos]="todos" (toggle)="toggleCompletion($event)"></todo-list> 
  ` 
}) 
class TodoApp {...} 

```

最初，我们定义`TodoApp`类并用`@Component`装饰器装饰它。请注意，为了使用`InputBox`和`TodoList`组件，我们需要将它们包含在模块 decorator 的`declarations`属性中，该属性声明了`TodoApp`。这些组件如何协作的神奇之处在于模板：

```ts
<input-box inputPlaceholder="New todo..." 
  buttonLabel="Add" 
  (inputText)="addTodo($event)"> 
</input-box> 

```

首先，我们使用`InputBox`组件并将值传递给输入`inputPlaceholder`和`buttonLabel`。请注意，正如我们前面看到的，如果我们想将表达式作为值传递给这些输入中的任何一个，我们需要用括号将它们括起来（即，`[inputPlaceholder]="expression"`。在这种情况下，表达式将在拥有模板的组件的上下文中求值，结果将作为输入传递给拥有给定属性的组件。

在传递`buttonLabel`输入的值之后，我们通过将`(inputText)`属性的值设置为`addTodo($event)`表达式来使用`inputText`输出。*`$event`*的值将等于我们传递给*的`emitText`*方法中*`inputText`*对象的*`emit`*方法的值（如果绑定到本机事件，事件对象的值将是本机事件对象本身）。**

 *同样，我们传递`TodoList`组件的输入并处理其切换输出。现在，让我们来定义`TodoApp`组件背后的逻辑：

```ts
class TodoApp { 
  todos: Todo[] = []; 
  name: string = 'John';

  addTodo(label: string) { 
    this.todos.push({ 
      label, 
      completed: false 
    }); 
  }

  toggleCompletion(todo: Todo) { 
    todo.completed = !todo.completed; 
  } 
} 

```

在`addTodo`方法中，我们只需将一个新的待办事项推送到`todos`数组中。`toggleCompletion`的实现更简单：我们切换作为参数传递给 to-do 项的 completed 标志的值。现在，我们已经熟悉了组件输入和输出的基本知识。

## 事件冒泡

在 Angular 中，我们具有与 DOM 中相同的冒泡行为。例如，假设我们有以下模板：

```ts
<input-box inputPlaceholder="New todo..." 
  buttonLabel="Add" 
  (click)="handleClick($event)" 
  (inputText)="addTodo($event)"> 
</input-box> 

```

`input-box`的声明如下：

```ts
<input #todoInput [placeholder]="inputPlaceholder"> 
<button (click)="emitText(todoInput.value); 
                 todoInput.value = '';"> 
  {{buttonLabel}} 
</button> 

```

一旦用户点击`input-box`组件模板中定义的按钮，`handleClick($event)`表达式将被计算。

此外，`handleClick`的第一个参数的`target`属性将是按钮本身，而`currentTarget`属性将是`input-box`元素。如果不使用角度，事件将以相同的方式冒泡。在某个时刻，它将到达文档，除非处理程序不停止它的传播。

相反，如果我们有一个自定义的`@Output`，事件将不会冒泡，而不是 DOM 事件，`$event`变量的值将是我们传递给输出的 emit 方法的值。

## 重命名输入和输出

现在，我们将探讨如何重命名指令的输入和输出。假设我们对`TodoList`组件有以下定义：

```ts
class TodoList { 
  ... 
  @Output() toggle = new EventEmitter<Todo>();

  toggle(index: number) { 
    ... 
  } 
} 

```

组件的输出称为`toggle`；处理负责切换单个待办事项完成情况的复选框中的更改的方法也称为`toggle`。这段代码不会被编译，因为在`TodoList`控制器中，我们有两个以相同方式命名的标识符。我们有两个选择：

*   我们可以重命名该方法。
*   我们可以重命名该属性。

如果重命名该属性，这也将更改组件输出的名称。因此，以下代码行将不再工作：

```ts
<todo-list [toggle]="foobar($event)"...></todo-list> 

```

我们可以改为重命名`toggle`属性，并使用`@Output`装饰器显式设置输出的名称：

```ts
class TodoList { 
  ... 
  @Output('toggle') toggleEvent = new EventEmitter<Todo>();

  toggle(index: number) { 
    ... 
  } 
} 

```

这样，我们就可以使用`toggleEvent`属性触发`toggle`输出。

### 注

请注意，这样的重命名可能会令人困惑，并且不被视为最佳做法。有关完整的最佳实践，请访问[https://angular.io/styleguide](https://angular.io/styleguide)。

类似地，我们可以使用以下代码段重命名组件的输入：

```ts
class TodoList { 
  @Input('todos') todoList: Todo[]; 
  @Output('toggle') toggleEvent = new EventEmitter<Todo>();

  toggle(index: number) { 
    ... 
  } 
} 

```

现在，我们重命名`TodoList`的输入和输出属性并不重要；它仍然具有相同的公共接口：

```ts
<todo-list [todos]="todos" 
  (toggle)="toggleCompletion($event)"> 
</todo-list> 

```

## 定义输入和输出的替代语法

`@Input`和`@Output`修饰符是语法糖，用于更容易地声明指令的输入和输出。用于此目的的原始语法如下所示：

```ts
@Directive({ 
  outputs: ['outputName: outputAlias'], 
  inputs: ['inputName: inputAlias'] 
}) 
class Dir { 
  outputName = new EventEmitter(); 
} 

```

使用`@Input`和`@Output`，前面的语法等价于：

```ts
@Directive(...) 
class Dir { 
  @Output('outputAlias') outputName = new EventEmitter<any>(); 
  @Input('inputAlias') inputName: any;
} 

```

虽然两者具有相同的语义，但根据最佳实践，我们应该使用后一种，因为它更易于阅读和理解。

# 解释 Angular 的内容投影

内容投影是开发用户界面时的一个重要概念。它允许我们将内容片段投射到应用程序用户界面的不同位置。Web 组件通过`content`元素解决了这个问题。在 AngularJS 中，它是通过臭名昭著的转换实现的。

Angular 的灵感来自于现代 Web 标准，尤其是 Web 组件，这导致采用了其中使用的一些内容投影方法。在本节中，我们将使用[T0]指令在 Angular 的上下文中查看它们。

## 角度投影的基本内容

假设我们正在构建一个名为`fancy-button`的组件。该组件将使用标准的 HTML 按钮元素，并向其添加一些额外的行为。以下是`fancy-button`组件的定义：

```ts
@Component({ 
  selector: 'fancy-button', 
  template: '<button>Click me</button>' 
}) 
class FancyButton { ... } 

```

在`@Component`装饰器内部，我们设置组件的内联模板及其选择器。现在，我们可以使用具有以下标记的组件：

```ts
<fancy-button></fancy-button> 

```

在屏幕上，我们将看到一个标准的 HTML 按钮，其标签上有内容**Click me**。这不是一种非常灵活的定义可重用 UI 组件的方法。最有可能的是，花式按钮的用户需要根据其应用程序将标签的内容更改为其他内容。

在 AngularJS 中，我们通过`ng-transclude`实现了这一结果：

```ts
// AngularJS example 
app.directive('fancyButton', function () { 
  return { 
    restrict: 'E', 
    transclude: true, 
    template: '<button><ng-transclude></ng-transclude></button>' 
  }; 
}); 

```

在新的 Angular 中，我们有`ng-content`元素：

```ts
// ch4/ts/ng-content/app.ts 
@Component({ 
  selector: 'fancy-button', 
  template: '<button><ng-content></ng-content></button>' 
}) 
class FancyButton { /* Extra behavior */ } 

```

现在，我们可以通过执行以下操作将自定义内容传递到 fancy 按钮：

```ts
<fancy-button>Click <i>me</i> now!</fancy-button> 

```

因此，开始和结束`fancy-button`标记之间的内容将放置在`ng-content`指令所在的位置。

## 投射多个内容块

内容投影的另一个典型用例是，当我们将内容传递给自定义角度组件或 AngularJS 指令时，我们希望将此内容的不同部分投影到模板中的不同位置。

例如，假设我们有一个`panel`组件，它有一个标题和一个正文，我们可以用以下方式使用它：

```ts
<panel>
  <section class="panel-title">Sample title</section>
  <section class="panel-content">Content</section>
</panel>

```

我们`panel`组件的模板如下所示：

```ts
<div class="panel"> 
  <div class="panel-title"> 
    <!-- Project the content of panel-title here --> 
  </div> 
  <div class="panel-content"> 
    <!-- Project the content of panel-content here --> 
  </div> 
</div>` 

```

在 AngularJS 1.5 中，我们可以使用多时隙转换来实现这一点，实现多时隙转换是为了让我们能够更平滑地过渡到 AngularJS 2 及更高版本。让我们来看看我们如何在角度上进行，以便定义这样一个有趣的组件：

```ts
// ch4/ts/ng-content/app.ts 
@Component({ 
  selector: 'panel', 
  styles: [ ... ], 
  template: ` 
    <div class="panel"> 
      <div class="panel-title"> 
        <ng-content select=".panel-title"></ng-content> 
      </div> 
      <div class="panel-content"> 
        <ng-content select=".panel-content"></ng-content> 
      </div> 
    </div>` 
}) 
class Panel { } 

```

我们已经描述了 AutoT0 和 Ty1 T1 属性，所以让我们来看一看组件的模板。我们有一个带有`panel`类的`div`元素，它分别包装了两个嵌套的`div`元素——一个用于`panel`的标题，另一个用于`panel`的内容。

为了将类名为`panel-title`的`section`元素的内容投射到标题应该所在的位置，我们需要使用`ng-content`元素。作为它的`selector`属性，我们需要使用一个 CSS 选择器，它匹配我们想要投影其内容的元素（在本例中，选择器应该是`.panel-title`或`section.panel-title`。

如果我们将`selector`属性的值设置为`.panel-title`，那么它将匹配目标`panel`元素中的`.panel-title`类的所有元素。在此之后，`ng-content`将获取它们的内容并将其设置为自己的内容。

## 嵌套组件

我们已经构建了一些由组件和指令组成的简单应用程序。我们看到组件基本上是带有视图的指令，所以我们可以通过嵌套或组合其他指令和组件来实现它们。下图用结构图说明了这一点：

![Nesting components](graphics/B06166_04_09.jpg)

图 9

组合可以通过在组件模板中嵌套指令和组件来实现，利用所用标记的嵌套特性。例如，假设我们有一个带有`sample-component`选择器的组件，其定义如下：

```ts
@Component({ 
  selector: 'sample-component', 
  template: '<view-child></view-child>' 
}) 
class Sample {} 

```

`Sample`组件的模板有一个子元素，标记名为`view-child`。

另一方面，我们可以在另一个组件的模板中使用`Sample`组件，因为它可以用作元素，我们也可以在其中嵌套其他组件或指令：

```ts
<sample-component> 
  <content-child1></content-child1> 
  <content-child2></content-child2> 
</sample-component> 

```

通过这种方式，`sample-component`组件有两种不同类型的后继体：

*   在其模板中定义的继承者。
*   后续项作为嵌套元素在其开始标记和结束标记之间传递。

在 Angular 的上下文中，组件模板中定义的直接子元素称为**视图子元素**，嵌套在其开始标记和结束标记之间的元素称为**内容子元素**。

## 使用 ViewChildren 和 ContentChildren

让我们看看胡 T0 组件的实现，它使用以下结构：

```ts
<tabs (changed)="tabChanged($event)"> 
  <tab-title>Tab 1</tab-title> 
  <tab-content>Content 1</tab-content> 
  <tab-title>Tab 2</tab-title> 
  <tab-content>Content 2</tab-content> 
</tabs> 

```

上述结构由三部分组成：

*   `Tab`组件
*   `TabTitle`组件
*   `TabContent`组件

让我们来看看 Apple T0 组件的实现：

```ts
@Component({ 
  selector: 'tab-title', 
  styles: [...], 
  template: ` 
    <div class="tab-title" (click)="handleClick()"> 
      <ng-content></ng-content> 
    </div> 
  ` 
}) 
class TabTitle { 
  @Output() tabSelected: EventEmitter<TabTitle> = 
    new EventEmitter<TabTitle>();

  handleClick() { 
    this.tabSelected.emit(this); 
  } 
} 

```

这个实现中没有什么新东西。我们定义了一个`TabTitle`组件，它有一个名为`tabSelected`的属性。属于`EventEmitter`类型，一旦用户点击标签标题就会触发。

现在，让我们来看看 PosiT0.组件：

```ts
@Component({ 
  selector: 'tab-content', 
  styles: [...], 
  template: ` 
    <div class="tab-content" [hidden]="!isActive"> 
      <ng-content></ng-content> 
    </div> 
  ` 
}) 
class TabContent { 
  isActive: boolean = false; 
} 

```

这有一个更简单的实现——我们所做的就是将传递给`ng-content`中的`tab-content`元素的 DOM 投影出来，并在`isActive`属性的值变为`false`后将其隐藏。

实现的有趣部分是`Tabs`组件本身：

```ts
// ch4/ts/basic-tab-content-children/app.ts 
@Component({ 
  selector: 'tabs', 
  styles: [...], 
  template: ` 
    <div class="tab"> 
      <div class="tab-nav"> 
        <ng-content select="tab-title"></ng-content> 
      </div> 
      <ng-content select="tab-content"></ng-content> 
    </div> 
  ` 
}) 
class Tabs { 
  @Output('changed') 
  tabChanged: EventEmitter<number> = new EventEmitter<number>(); 

  @ContentChildren(TabTitle) 
  tabTitles: QueryList<TabTitle>; 

  @ContentChildren(TabContent) 
  tabContents: QueryList<TabContent>; 

  active: number;
  select(index: number) {...} 
  ngAfterViewInit() {...} 
} 

```

在这个实现中，我们有一个尚未使用的装饰器：`@ContentChildren`装饰器。`@ContentChildren`属性装饰器获取给定组件的内容子级。这意味着我们可以从`Tabs`组件的实例中获取对所有`TabTitle`和`TabContent`实例的引用，并按照它们在标记中声明的顺序获取它们。还有一个名为`@ViewChildren`的替代装饰器，它获取给定元素的所有视图子元素。让我们先看看 VIEW 儿童与内容儿童之间的差异，然后再解释进一步的实现。

## ViewChild 与 ContentChild

虽然这两个概念听起来相似，但它们的语义却截然不同。为了更好地理解它们，我们来看看下面的例子：

```ts
// ch4/ts/view-child-content-child/app.ts 
@Component({ 
  selector: 'user-badge', 
  template: '...' 
}) 
class UserBadge {} 

@Component({ 
  selector: 'user-rating', 
  template: '...' 
}) 
class UserRating {} 

```

在这里，我们定义了两个组件：`UserBadge`和`UserRating`。让我们定义一个父组件，它包含两个组件：

```ts
@Component({ 
  selector: 'user-panel', 
  template: '<user-badge></user-badge>'
}) 
class UserPanel {...} 

```

注意，`UserPanel`视图的模板只包含`UserBadge`组件的选择器。现在，让我们在应用程序中使用`UserPanel`组件：

```ts
@Component({ 
  selector: 'app', 
  template: `<user-panel> 
    <user-rating></user-rating> 
  </user-panel>`
}) 
class App {} 

```

我们的主`App`组件的模板使用`UserPanel`组件，并将`UserRating`组件嵌套在其中。现在，假设我们想要获得一个对`App`模板中`user-panel`元素内部使用的`UserRating`组件实例的引用，以及对`UserPanel`模板内部使用的`UserBadge`组件的引用。为了做到这一点，我们可以向`UserPanel`控制器添加另外两个属性，并使用适当的参数向其添加`@ContentChild`和`@ViewChild`装饰器：

```ts
class UserPanel { 
  @ViewChild(UserBadge) 
  badge: UserBadge; 

  @ContentChild(UserRating) 
  rating: UserRating;

  constructor() { 
    // 
  } 
} 

```

`badge`属性声明的语义是“获取`UserBadge`类型的第一个子组件的实例，该实例在`UserPanel`模板中使用”。因此，`rating`属性声明的语义是“获取类型为`UserRating`的第一个子组件的实例，该子组件嵌套在`UserPanel`宿主元素中”。

现在，如果您运行这段代码，您会注意到，`badge`和`rating`属性的值仍然等于控制器构造函数中的`undefined`值。这是因为在组件生命周期的这个阶段，它们仍然没有初始化。为了获得对这些子组件的引用，我们可以使用的生命周期挂钩是`ngAfterViewInit`和`ngAfterContentInit`。我们可以简单地通过向组件的控制器添加`ngAfterViewInit`和`ngAfterContentInit`方法的定义来使用这些钩子。我们将很快对 Angular 提供的生命周期挂钩进行全面概述。

总而言之，我们可以说给定组件的内容子元素是嵌套在组件的宿主元素中的子元素。相反，给定组件的视图子级指令是其模板中使用的元素。

### 注

为了获得对 DOM 元素的独立于平台的引用，我们同样可以使用`@ContentChild`和`@ViewChild`。例如，如果我们有以下模板：`<input #todo>`我们可以通过使用：`@ViewChild('todo')`获得对`input`的引用。

由于我们现在已经熟悉了视图子项和内容子项之间的核心区别，我们可以继续我们的选项卡实现。

在 tabs 组件中，我们使用[T1]，而不是使用[T0]装饰器。我们之所以这样做，是因为我们有多个内容子项，我们希望将它们全部获取：

```ts
@ContentChildren(TabTitle) 
tabTitles: QueryList<TabTitle>; 

@ContentChildren(TabContent) 
tabContents: QueryList<TabContent>; 

```

我们要注意的另一个主要区别是，`tabTitles`和`tabContents`属性的类型是`QueryList`及其各自的类型参数，而不是组件的类型本身。我们可以将`QueryList`数据结构视为 JavaScript 数组–我们可以在其上应用相同的高阶函数（`map`、`filter`、`reduce`等等），并在其元素上循环；然而，`QueryList`也是可以观察到的，也就是说，我们可以观察它的变化。

作为我们的 To.T0 定义的最后一步，让我们来窥探一下 ToalT1 和 Ty2 T2 方法的实现：

```ts
ngAfterContentInit() { 
  this.tabTitles 
    .map(t => t.tabSelected) 
    .forEach((t, i) => { 
      t.subscribe(_ => { 
        this.select(i) 
      }); 
    }); 
  this.active = 0; 
  this.select(0); 
} 

```

在方法实现的第一行中，我们循环所有`tabTitles`并获取可观察对象的引用。这些对象有一个名为`subscribe`的方法，该方法接受回调作为参数。一旦调用了`EventEmitter`实例的`.emit()`方法（即任何选项卡的`tabSelected`属性），就会调用传递给`subscribe`方法的回调。

现在，让我们来看看 Apple T0 方法的实现：

```ts
select(index: number) { 
  let contents: TabContent[] = this.tabContents.toArray(); 
  contents[this.active].isActive = false; 
  this.active = index; 
  contents[this.active].isActive = true; 
  this.tabChanged.emit(index); 
} 

```

在第一行中，由于`tabContents`属于`QueryList<TabContent>`类型，我们得到了它的数组表示。之后，我们将当前活动选项卡的`isActive`标志设置为`false`，并选择下一个活动选项卡。在`select`方法实现的最后一行中，我们使用当前所选选项卡的索引调用`this.tabChanged.emit`来触发`Tabs`组件的所选事件。

# 与组件的生命周期挂钩

Angular 中的组件有一个定义良好的生命周期，这允许我们连接到它的不同阶段，并进一步控制我们的应用程序。我们可以通过在组件的控制器中实现特定的方法来实现这一点。为了更加明确，由于 TypeScript 的表达能力，我们可以实现与生命周期阶段相关的不同接口。每个接口都有一个单独的方法，该方法与阶段本身相关联。

尽管使用显式接口实现编写的代码具有更好的语义，但由于 Angular 也支持 ES5，因此在组件中，我们可以简单地定义与生命周期挂钩同名的方法（但这次，前缀为[T0]），并利用 duck 类型。

下图显示了我们可以连接到的所有阶段：

![Hooking into the component's life cycle](graphics/B06166_04_10.jpg)

图 10

让我们来看看不同的生命周期钩子：

*   `OnChanges`：一旦检测到给定组件的输入属性发生变化，就会调用此钩子。例如，让我们来看看下面的组件：

```ts
      @Component({ 
        selector: 'panel', 
        inputs: ['title'] 
      }) 
      class Panel {...} 

```

我们可以这样使用它：

```ts
<panel [title]="expression"></panel> 

```

一旦与`[title]`属性关联的表达式的值被更改，就会调用`ngOnChanges`钩子。我们可以使用以下代码段实现它：

```ts
@Component(...) 
class Panel { 
  ngOnChanges(changes) { 
    Object.keys(changes).forEach(prop => { 
      console.log(prop, 'changed. Previous value', changes[prop].previousValue); 
    }); 
  } 
} 

```

前面的代码段将显示所有已更改的绑定及其旧值。为了在钩子的实现中更加明确，我们可以使用接口：

```ts
import {Component, OnChanges} from '@angular/core'; 
@Component(...) 
class Panel implements OnChanges { 
  ngOnChanges(changes) {...} 
} 

```

代表单个生命周期钩子的所有接口都声明了一个方法，接口本身的名称前缀为`ng`。在接下来的列表中，我们将使用“生命周期挂钩”一词，用于接口和/或方法，除非我们不会特别针对其中一个。

*   `OnInit`：一旦给定组件初始化，就会调用此钩子。我们可以使用`OnInit`接口及其`ngOnInit`方法来实现它。
*   `DoCheck`：当调用给定组件的变更检测器时，将调用此选项。它允许我们为给定组件实现自己的更改检测算法。请注意，`DoCheck`和`OnChanges`不应在同一指令上同时执行。
*   `OnDestroy`：如果我们用`OnDestroy`接口的`ngOnDestroy`方法实现`OnDestroy`接口，我们就可以钩住组件的销毁生命周期阶段。一旦组件从组件树中分离，就会调用此方法。

现在，让我们来看一看与组件的内容和视图相关的生命周期挂钩：

*   `AfterContentInit`：如果我们实现`ngAfterContentInit`生命周期钩子，组件内容完全初始化时会通知我们。这是使用`ContentChild`或`ContentChildren`装饰的属性将被初始化的阶段。
*   `AfterContentChecked`：通过实现这个钩子，我们将在 Angular 的更改检测机制每次检查给定组件的内容时收到通知。
*   `AfterViewInit`：如果我们用`ngAfterViewInit`方法实现这个生命周期钩子，组件视图初始化时会通知我们。这是使用`ViewChild`或`ViewChildren`装饰的属性将被初始化的阶段。
*   `AfterViewChecked`：与`AfterContentChecked`类似。检查组件的视图后，`AfterViewChecked`钩子将被调用。

## 生命周期挂钩的执行顺序

为了跟踪与每个钩子相关联的回调的执行顺序，让我们看一下 Type T0.例子：

```ts
@Component({ 
  selector: 'panel', 
  template: '<ng-content></ng-content>' 
}) 
class Panel { 
  @Input() title: string;
  @Input() caption: string;
  ngOnChanges(changes) {...} 
  ngOnInit() {...} 
  ngDoCheck() {...} 
  ngOnDestroy() {...} 
  ngAfterContentInit() {...} 
  ngAfterContentChecked() {...} 
  ngAfterViewInit() {...} 
  ngAfterViewChecked() {...} 
} 

```

`Panel`组件实现了所有钩子，而没有显式地实现与它们相关联的接口。

我们可以在以下模板中使用该组件：

```ts
<button (click)="toggle()">Toggle</button> 
<div *ngIf="counter % 2 == 0"> 
  <panel caption="Sample caption" >Hello world!</panel> 
</div> 

```

在前面的示例中，我们有一个面板和一个按钮。每次点击按钮后，`ngIf`指令会将面板移除或附加到视图中。

在应用程序初始化过程中，如果将`"counter % 2 == 0"`表达式的结果求值为`true`，则会调用`ngOnChanges`方法。这是因为标题和标题属性的值将首次设置。

紧接着，将调用`ngOnInit`方法，因为组件已经初始化。组件初始化完成后，将触发更改检测，这将导致调用`ngDoCheck`方法，该方法允许我们钩住自定义逻辑以检测状态的更改。

### 注

请注意，您不应该为同一个组件同时实现`ngDoCheck`和`ngOnChanges`方法，因为当内部变更检测器检测到变更时，`ngOnChanges`将一直被调用。这里的示例仅用于学习目的。

在`ngDoCheck`方法之后，变更检测器将对组件的内容进行检查（`ngAfterContentInit`和`ngAfterContentChecked`将按此顺序调用）。紧接着，组件的视图也会发生同样的情况（`ngAfterViewInit`后跟`ngAfterViewChecked`。

一旦将[T0]指令的表达式求值为[T1]，整个组件将从视图中分离，这将导致调用[T2]钩子。

在下一次单击时，如果`ngIf`表达式的值等于`true`，则将执行与初始化阶段相同的生命周期挂钩调用顺序。

# 使用 TemplateRef 定义通用视图

我们已经熟悉了输入、内容子项和视图子项的概念，也知道何时可以在组件的生命周期中获得对它们的引用。现在，我们将把它们结合起来，引入一个新概念——`TemplateRef`。

让我们后退一步，看看本章早些时候开发的最后一个待办事项。在以下屏幕截图中，您可以看到其 UI 的外观：

![Defining generic views with TemplateRef](graphics/11-1.jpg)

图 11

如果我们看一下它在`ch4/ts/inputs-outputs/app.ts`中的实现，我们将看到用于呈现单个待办事项的模板是在整个待办事项应用程序的模板中定义的。

如果我们想使用不同的布局来呈现待办事项，该怎么办？我们可以通过创建另一个名为`Todo`的组件来实现这一点，该组件封装了呈现它们的职责。然后，我们可以为我们想要支持的不同布局定义单独的`Todo`组件。这样，我们需要为*n*不同的布局提供*n*不同的组件，即使我们只需要更改它们的模板。

Angular 提供了更优雅的解决方案。在本章前面，我们已经讨论了模板元素。我们说过它允许我们定义一个不会被浏览器处理的 HTML 块。Angular 允许我们引用这些模板元素，并通过将它们作为内容子元素传递来使用它们。

下面是我们如何将自定义布局传递给重构的`TodoApp`组件：

```ts
// ch4/ts/template-ref/app.ts 
<todo-app> 
  <template let-todo> 
    <input type="checkbox" [checked]="todo.completed" 
      (change)="todo.completed = !todo.completed;"> 
    <span [class.completed]="todo.completed"> 
      {{todo.label}} 
    </span><br> 
  </template> 
</todo-app> 

```

在模板中，我们声明了一个名为`todo`的变量。在模板的后面，我们可以使用它来指定可视化内容的方式。

现在，让我们来看看在 ToR.T0.组件的控制器中如何获得对该模板的引用：

```ts
// ch4/ts/template-ref/app.ts 
class TodoApp { 
  @ContentChild(TemplateRef) itemsTemplate: TemplateRef; 
  // ... 
} 

```

我们在这里所做的就是定义一个名为`itemsTemplate`的属性，并用`@ContentChild`装饰器对其进行装饰。在组件的生命周期内（更准确地说，在`ngAfterContentInit`中，`itemsTemplate`的值将被设置为我们作为`todo-app`元素内容传递的模板的引用。

不过还有一个问题——我们需要`TodoList`组件中的模板，因为这是我们渲染单个待办事项的地方。我们可以定义`TodoList`组件的另一个输入，并直接从`TodoApp`传递模板：

```ts
// ch4/ts/template-ref/app.ts 
class TodoList { 
  @Input() todos: Todo[]; 
  @Input() itemsTemplate: TemplateRef; 
  @Output() toggle = new EventEmitter<Todo>(); 
} 

```

我们需要将其作为`TodoApp`模板的输入传递：

```ts
... 
<todo-list [todos]="todos" 
  [itemsTemplate]="itemsTemplate"> 
</todo-list> 

```

剩下的就是在`TodoList`应用程序的模板中使用此模板引用：

```ts
<!-- ... --> 
<template *ngFor="let todo of todos; template: itemsTemplate"></template> 

```

在本章前面的章节中，我们已经解释了`ngForOf`指令的扩展语法。前面的代码片段显示了我们可以设置的该指令的另一个属性：`ngForTemplate`属性。默认情况下，`ngForOf`指令的模板是它所使用的元素。通过指定对`ngForTemplate`属性的模板引用，我们可以使用传递的`TemplateRef`。

# 了解并加强变化检测

我们已经简要描述了框架的变化检测机制。我们说过，与 AngularJS 相比，AngularJS 在“范围”的上下文中运行，在 Angular2 和更高版本中，它在单个组件的上下文中运行。我们提到的另一个概念是区域，它基本上拦截我们使用浏览器 API 进行的所有异步调用，并为框架的更改检测机制提供执行上下文。Zones 修复了 AngularJS 中的恼人问题，当我们在 AngularJS 之外使用 API 时，我们需要显式地调用`digest`循环。

在[第一章](1.html "Chapter 1. Get Going with Angular")、*开始使用 Angular*和[第二章](2.html "Chapter 2. The Building Blocks of an Angular Application")、*Angular 应用程序的构建块*中，我们讨论了正在生成对组件执行更改检测的代码，无论是运行时（**准时**）或者作为我们构建过程的一部分（**提前**）。AoT 编译对于具有严格的**CSP**（**内容安全策略**）的环境非常有效，因为禁用了 JavaScript 的动态评估功能；它还提供了更好的性能，因为 Angular 不必编译组件的模板。我们将在[第 8 章](8.html "Chapter 8. Tooling and Development Experience")、*工具和开发经验*中详细解释。

在本节中，我们将探讨`@Component`装饰器的配置对象的另一个属性，它通过改变框架的策略来进一步控制框架的变化检测机制。通过显式地设置策略，我们能够防止更改检测机制在组件的子树上运行，这在某些情况下可以带来巨大的性能优势。

## 变更检测器的执行顺序

现在，让我们简要描述在给定组件树中调用更改检测器的顺序。

为此，我们将使用我们拥有的待办事项应用程序的最后一个实现，但这一次，我们将提取逻辑以将各个待办事项呈现到一个名为 TodoItem 的单独组件中。在下图中，我们可以看到应用程序的结构：

![The order of execution of the change detectors](graphics/B06166_04_12.jpg)

图 12

顶层是**TodoApp**组件，它有两个子组件：**InputBox**和**TodoList**。**TodoList**组件使用**TodoItem**组件呈现各个待办事项。实施细节对于我们的目的并不重要，因此我们将忽略它们。

现在，我们需要认识到父组件的状态与其子组件的状态之间存在隐式依赖关系。例如，**TodoList**组件的状态完全取决于位于其父级的待办事项：**TodoApp**组件。**TodoItem**和**TodoList**之间存在类似的依赖关系，因为**TodoList**组件将各个待办事项传递给**TodoItem**组件的单独实例。这意味着如果**TodoList**中的待办事项列表发生变化，这将自动反映**TodoItem**中的一些组件：

![The order of execution of the change detectors](graphics/B06166_04_13.jpg)

图 13

根据我们上次的观察，连接到各个组件的变更检测器的执行顺序与上图所示的顺序相同。一旦变更检测机制运行，它将首先对**TodoApp**组件执行检查。在此之后，将检查**输入框**组件的更改，然后检查**TodoList**组件。最后，Angular 将调用**TodoItem**组件的更改检测器。

您可以在`ch4/ts/change_detection_strategy_order/app.ts`示例中跟踪执行顺序，其中每个组件在其`ngDoCheck`方法被调用后都会记录一条消息。

### 注

注意，只有组件有一个变更检测器的实例连接到它们；指令使用其父组件的更改检测器。

## 理解 Angular 的变化检测策略

Angular 提供的变化检测策略是`Default`和`OnPush`。我们将详细描述如何利用`OnPush`，因为它在处理不可变数据时非常强大。

现在，让我们导入 TypeScript 枚举，它可用于配置用于各个组件的策略：

```ts
// ch4/ts/change_detection_strategy_broken/app.ts 

import {ChangeDetectionStrategy} from '@angular/core'; 

```

现在，我们可以将`TodoList`组件配置为使用`OnPush`策略：

```ts
@Component({ 
  selector: 'todo-list', 
  changeDetection: ChangeDetectionStrategy.OnPush, 
  template: `...`, 
  styles: [...] 
}) 
class TodoList { ... } 

```

这样，将跳过更改检测，直到组件没有接收到具有不同值的输入。请注意，比较使用相等检查，这意味着它将通过比较基元类型的值和对象的引用来比较基元类型。您可以转到`http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`并查看`TodoList`组件的不一致行为。当您在输入中添加新的待办事项并单击**添加**按钮时，它不会立即出现在列表中。

默认情况下，更改检测将始终检查更改。

## 引入不可变数据结构和 OnPush

现在，我们将描述`OnPush`变更检测策略。当给定组件产生的结果仅取决于其输入时，它非常有用。在这种情况下，我们可以将不可变的数据传递给它的输入，以确保它不会被任何组件变异。这样，通过让一个组件只依赖于其不可变的输入，并且不产生任何副作用，我们可以确保它只在接收到不同的输入（即，具有不同的引用）时才产生不同的用户界面。

在本节中，我们将对`TodoList`组件应用`OnPush`策略。因为它只依赖于它的输入（`todos`输入），所以我们希望确保只有在它接收到`todos`集合的新引用时，才会执行它的更改检测。

不可变数据的本质是它不能改变。这意味着一旦我们创建了`todos`集合，我们就无法更改它；相反，`add`（或者，在我们的例子中，`push`）方法将返回一个新集合，即包含新项目的初始集合的副本。

在每次更改时复制整个集合似乎会产生巨大的开销。在大型应用程序中，这可能会对性能产生很大影响。但是，我们不需要复制整个集合。有些库使用更智能的算法（例如，持久数据结构）实现不可变的数据结构。持久数据结构超出当前内容的范围。关于它们的更多信息可以在大多数高级数据结构的计算机科学教科书中找到。好的是，我们不必为了使用它们而深入了解它们的实现。有一个名为*Immutable.js*的库，它实现了一些常用的不可变数据结构。在本例中，我们将使用不可变列表。通常，不可变列表的行为与普通列表类似，但在每个假定对其进行变异的操作上，它都会返回一个新的不可变列表。

这意味着，如果我们有一个名为`foo`的列表，它是不可变的，并在列表中附加一个新项，我们将得到一个新的引用：

```ts
let foo = List.of(1, 2, 3); 
let changed = foo.push(4); 
foo === changed // false 
console.log(foo.toJS()); // [ 1, 2, 3 ] 
console.log(changed.toJS()); // [ 1, 2, 3, 4 ] 

```

为了利用不变性，我们需要使用 npm 安装 Immutable.js。

该库已经是包含该书代码的项目的一部分。您可以在项目根目录中的`package.json`中找到对 Immutable.js 的引用。您可以查看`ch4/ts/change_detection_strategy/app.ts`以了解我们如何在 TypeScript 应用程序中包含不可变集合。

现在，是时候重构我们的待办事项应用程序并使其使用不可变数据了。

## 使用角度不可变数据

让我们来看看我们当前如何在 ToYT0:组件中保持待办事项：

```ts
class TodoApp { 
  todos: Todo[] = [...]; 
  ... 
} 

```

我们使用一组`Todo`项。JavaScript 数组是可变的，这意味着如果我们将其传递给使用`OnPush`策略的组件，那么在获得相同的输入引用时跳过更改检测是不安全的。例如，我们可能有两个组件使用相同的待办事项列表。这两个组件都可以修改列表，因为它是可变的。如果未执行任何组件的更改检测，这将导致任何组件的状态不一致。这就是为什么我们需要确保保存项目的列表是不可变的。为了确保`TodoApp`组件将其数据保存在不可变的数据结构中，我们需要在`TodoApp`组件中执行以下操作：

```ts
// ch4/ts/change_detection_strategy/app.ts 
class TodoApp { 
  todos: Immutable.fromJS([{ 
    label: 'Buy milk', 
    completed: false 
  }, { 
    label: 'Save the world', 
    completed: false 
  }]);
  ... 
} 

```

通过这种方式，我们将`todos`属性构造为不可变列表，其中包含不可变对象；我们只需要调用 Immutable.js 导出的函数`fromJS`。它将递归地将任何 JavaScript 对象转换为不可变对象。

接下来，由于不可变列表的突变操作会返回一个新的列表，我们需要在`addTodo`和`toggleTodoCompletion`中做一点修改：

```ts
... 
addTodo(label: string) { 
  this.todos = this.todos.push(Immutable.fromJS({ 
    label, 
    completed: false 
  })); 
}

toggleCompletion(index: number) { 
  this.todos = this.todos.update(index, todo => { 
    return Immutable.fromJS({ 
      label: todo.label, 
      completed: !todo.completed 
    });
  }); 
} 
... 

```

`addTodo`函数看起来与之前完全相同，只是我们将`push`方法的结果设置为`todos`属性的值。

在`toggleTodoCompletion`中，我们使用不可变列表的`update`方法。作为第一个参数，我们传递要修改的待办事项的索引，第二个参数是执行实际修改的回调。注意，由于我们在本例中使用不可变数据，因此我们复制了修改后的 to-do 项。这是必需的，因为它告诉`update`方法具有给定索引的项已更改（因为它是不可变的，只有当它具有新引用时才被视为已更改），这意味着整个列表已更改。

这是最复杂的部分！现在，让我们看一下组件的定义：

```ts
@Component({ 
  selector: 'todo-list', 
  changeDetection: ChangeDetectionStrategy.OnPush, 
  template: `...`, 
  styles: [...] 
}) 
class TodoList { 
  @Input() todos: ImmutableList<Todo>; 
  @Output() toggle = new EventEmitter<number>();

  toggleCompletion(index: number) { 
    this.toggle.emit(index); 
  } 
} 

```

最后，我们需要修改访问模板中不可变待办事项属性的方式：

```ts
<ul>
  <li *ngFor="let todo of todos; let index = index"
      [class.completed]="todo.get('completed')">
     <input type="checkbox" [checked]="todo.get('completed')"
       (change)="toggleCompletion(index)">
    {{todo.get('label')}}
  </li>
</ul>
```

我们在这里所做的更改是，我们不使用直接属性访问，例如`todo.completed`，而是通过将我们想要获取的值作为字符串传递给属性来调用对象的`get`方法，在本例中为`"completed"`。

在`@Component`装饰器中，我们将`changeDetection`属性设置为`OnPush`策略的值。这意味着组件只有在其任何输入获得新引用时才会运行其更改检测器。除了属性访问之外，组件模板内部的所有其他内容都保持完全相同，因为`ngForOf`在内部使用 ES2015 迭代器在提供的集合中循环项目。Immutable.js 支持它们，因此不需要更改模板。

由于我们需要更改项的索引而不是其引用（我们在`TodoApp`中`todos`集合的`update`方法中使用的引用），因此我们将组件的输出类型更改为`EventEmitter<number>`。在`toggleCompletion`中，我们发出已更改待办事项的索引。

这就是我们优化简单待办应用程序的方法，防止更改检测机制在整个右子树中运行，以防父组件没有使用新引用推送输入。

# 总结

在本章中，我们介绍了 Angular 应用程序的核心构建块：指令和组件。我们构建了两个示例组件，向我们展示了用于定义这些基本概念的语法。我们还描述了每个指令的生命周期以及给定指令和组件的核心特性集。作为下一步，我们了解了如何使用具有不变数据的`OnPush`更改检测策略来提高应用程序的性能。

下一章将完全介绍 Angular 服务和框架的依赖注入机制。我们将了解如何定义和实例化定制注入器，以及如何利用指令和组件中的依赖项注入机制。*